---
title: "Natural selection in the Health and Retirement Study"
author: "David Hugh-Jones"
abstract: |
  I investigate natural selection on polygenic scores
  in the contemporary US, using the Health and Retirement Study. Results
  support the economic theory of fertility as an explanation for
  natural selection: among both white and black respondents,
  scores which correlate negatively (positively) with education are
  selected for (against). However, selection effects 
  are not larger among people with less education. 
  For whites, selection effects are smaller among married people. 
date: "September 2023"
format: 
  pdf:
    include-in-header:
      - text: |
          \usepackage{placeins}
    geometry:
    - top=2in
    - left=1.5in
    - right=1.5in
    - heightrounded
editor: visual
editor_options: 
  chunk_output_type: console
knitr:
  opts_chunk: 
    echo: false
bibliography: bibliography-hrs.bib
---

```{r}
#| label: setup


# TODO: ratio to family poverty threshold, h10inpovr
# 
# Is ADHD reverse-coded? - Doesn't seem to be, correlates negatively
#       with income
# What about XDISORDER?
# ADHD doesn't seem to be. Nor does XDISORDER (correlates with e.g. r*depres)

options(digits = 3)
set.seed(271075)

library(haven)
library(forcats)
library(dplyr, warn.conflicts = FALSE)
library(stringr)
library(purrr)
library(ggplot2)
library(tidyr)
library(santoku, warn.conflicts = FALSE) # masks tidyr::chop
 # masks dotchart:
suppressPackageStartupMessages(library(survey, warn.conflicts = FALSE))

nice_names <- c(
  SCZ         = "Schizophrenia",
  WC          = "Waist circ.",
  WHR         = "Waist-hip ratio",
  NEUROT      = "Neuroticism",
  WELLB       = "Well-being",
  DEPSYMP     = "Depr. symptoms",
  CD          = "Cor. art. disease",
  MI          = "Myoc. infarction",
  CORT        = "Cortisol",
  T2D         = "Type 2 diabetes",
  BIP         = "Bipolar",
  ADHD_PGC17  = "ADHD",
  XDISORDER   = "Cross-disorder",
  MENA        = "Age at menarche",
  MENO        = "Age at menopause",
  EXTRAVER    = "Extraversion",
  AUTISM      = "Autism",
  AB          = "Antisoc. behav.",
  OCD         = "OCD",
  AFBC        = "Age 1st birth combn",
  AFBF        = "Age 1st birth F",
  AFBM        = "Age 1st birth M",
  MDD2        = "Maj. depr. disorder",
  PTSDAA      = "PTSD Afr",
  PTSDEA      = "PTSD Eur",
  PTSDC       = "PTSD combined",
  HDL         = "HDL cholesterol",
  LDL         = "LDL cholesterol",
  TC          = "Total cholesterol",
  ANXFS       = "Anxiety CC", 
  ANXCC       = "Anxiety factor",
  BUN         = "Blood urea nitro.",
  BUNTE       = "Blood urea nitro. TE",
  CKD         = "Kidney disease",
  CKDTE       = "Kidney disease TE",
  DBP         = "Diastolic blood pr.",
  BMI2        = "BMI",
  HEIGHT2     = "Height",
  AI          = "Age smoking init.",
  CPD_GSCAN19 = "Cigs per day",
  DPW         = "Drinks per week",
  SC          = "Smoking cessation",
  SI          = "Smoking initiation",
  HTN         = "Hypertension",
  CANNABIS    = "Cannabis",
  GWAD2NA     = "Alzheimer's no APOE",
  ALZ_01AD2NA = "Alzheimer's p 0.01 no APOE",
  GWAD2WA     = "Alzheimer's",
  ALZ_01AD2WA = "Alzheimer's p 0.01",
  ALC         = "Alcohol dependence",
  PP          = "Pulse pressure",
  SBP         = "Systolic blood pr.",
  EGFR        = "Glom. filtr.",
  EGFRTE      = "Glom. filtr. TE",
  EA3         = "Educ. attainment",
  HBA1CAA     = "HbA1c Afr",
  HBA1CEA     = "HbA1c Eur",
  GCOG2       = "Gen. cognition"
)

eths <- c("white", "black")

titles <- c(white = "White", black = "Black")


shorten <- function (x) {
  x <- str_remove(x, "^(A4|E4)_")
  x_short <- str_remove(x, "_.*")

  duplicates <- table(x_short)
  duplicates <- names(duplicates)[duplicates > 1]
  x_short[x_short %in% duplicates] <- x[x_short %in% duplicates]

  x_short
}


calc_income <- function (x, eth) {
  x <- x |> filter(ethnicity == eth)
  ages <- x |> select(matches("r\\d+agey_e"))
  income <- x |> select(matches("r\\d+iearn"))
  income <- rowMeans(income, na.rm = TRUE)
  mod <- lm(income ~ factor(x$rabyear), weights = x$weight, na.action =
              na.exclude)
  income_r <- resid(mod)
  income_r <- income_r - min(income_r, na.rm = TRUE) + 1

  income_r
}


calc_n <- function (mods, eths = c("black", "white"), format = "(N = %s)") {
  nobs <- map_dbl(eths, \(x) nobs(mods[[x]][[1]]) ) 
  if (! is.null(format)) nobs <- sprintf(format, nobs)
  names(nobs) <- eths
  nobs
}


# avoid warnings about zero weights
svyglm_quiet <- function (...) suppressWarnings(svyglm(...))


# for a confidence interval
significant <- function (x) {
  stopifnot(is.numeric(x), length(x) == 2)
  all(x < 0) || all(x > 0)
}


insignificant <- Negate(significant)


confint_workaround <- function (x) {
  as.numeric(x) + c(-1.96, 1.96) * SE(x)
}


# rand HRS longit data. VERY BIG
# Done just once:
# rand_orig <- haven::read_dta("data/randhrs/randhrs1992_2020v1.dta")
# saveRDS(rand_orig, file = "data/randhrs/rand-orig.rds", compress = FALSE)
rand_orig <- readRDS("data/randhrs/rand-orig.rds")

# ragender: 1 male, 2 female
rand_orig <- filter(rand_orig, 
                    (rabyear <= 1965 & ragender == 1) |
                    (rabyear <= 1970 & ragender == 2))

# african ancestry
pgen4a <- haven::read_dta("data/PGENSCORE4r3/pgenscore4a_r.dta")
# european ancestry
pgen4e <- haven::read_dta("data/PGENSCORE4r3/pgenscore4e_r.dta")

# original HRS tracker file
trk_orig <- haven::read_dta("data/trk2020v3/trk2020tr_r.dta")
trk_weights <- trk_orig |> select(HHID, PN, matches("BIOWGTR"))

# rand family respondents file
rand_fam <- haven::read_dta(
  "data/randhrsfam1992_2018v2_STATA/randhrsfamr1992_2018v2.dta")
# only selected columns to avoid creating suffixes when we join with
# rand.
# Age of oldest kid; grandchildren; num siblings who died
rand_fam <- rand_fam |> select(hhid, pn, h10ageokid, h10gkid, r10sbdied)

pgens <- list(white = pgen4e, black = pgen4a)

pcs <- c(paste0("PC1_5", LETTERS[1:5]), paste0("PC6_10", LETTERS[1:5]))

rands <- list()

for (eth in eths) {
  pgen <- pgens[[eth]]
  names(pgen) <- shorten(names(pgen))
  rands[[eth]] <- inner_join(rand_orig, pgen,
                     join_by(hhid, pn),
                     unmatched = "drop",
                     relationship = "one-to-one")
}

rand <- list_rbind(rands, names_to = "ethnicity")

pgs <- pgen4e |>
    rename_with(shorten) |> 
    # weird that I have to operate on whole df to use select semantics
    select(-hhid, -pn, -version,
           -matches("^PC\\d"),
           -matches("^NEB"), # number ever born
           # outdated, or EDU3 without 23andMe:
           -EDU2, -EDU3, -HEIGHT, -BMI,
           -AD, -AD2, -GENCOG, -EVRSMK, -LONG, -CPD_TAG10,
           -ADHD_PGC10, -MDD
           ) |>
    names()



rand <- rand |> left_join(rand_fam, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

# weighting
rand <- left_join(rand, trk_weights, by = join_by(hhid == HHID, pn == PN))
rand$weight <- ifelse(is.na(rand$MBIOWGTR), rand$NBIOWGTR, rand$MBIOWGTR)
# compensate for fecund parents more likely to have child in survey.
# we use living sibs rather than including dead sibs too here. I think that's
# the correct approach:
rand$parent_weight <- rand$weight / (rand$r10livsib + 1)

rand <- rand |>
  mutate(.by = rabyear, # calculate this pooling ethnicity
    mean_raevbrn = mean(raevbrn, na.rm = TRUE),
    rlrs = raevbrn/mean_raevbrn
  ) |>
  mutate(.by = ethnicity, # calculate these stats within-ethnicity
    income_resid = calc_income(rand, ethnicity[1]),
    income_resid = income_resid - min(income_resid, na.rm = TRUE) + 1,
    income_med = chop_equally(income_resid, 2, labels = c("Low", "High")),
    # as.numeric avoids haven.labelled issues:
    raedyrs = as.numeric(raedyrs),
    edu = chop(as.numeric(raedyrs), 13, lbl_discrete(symbol = "-")),
    # wave 10 is 2010
    # table(rands$white$r10mstat)
     # 1                 1.married
     # 2   2.married,spouse absent
     # 3               3.partnered
     # 4               4.separated
     # 5                5.divorced
     # 6      6.separated/divorced
     # 7                 7.widowed
     # 8           8.never married
    married = factor(r10mstat == 1, 
                     levels = c(FALSE, TRUE),
                     labels = c("Other", "Married")),
    r10sibs = r10livsib + r10sbdied + 1, # n. sibs including oneself!
    agefb = r10agey_e - h10ageokid,
    agefb = ifelse(agefb < 12, NA_real_, agefb),
    agefb = chop_equally(agefb, 2, labels = c("Low", "High"))
  )

# two of four Alzheimer's variants with awkward names:
pgs <- str_replace(pgs, "^01", "ALZ_01")
names(rand) <- str_replace(names(rand), "^01", "ALZ_01")


rand <- rand |> 
  select(ethnicity, all_of(pgs), all_of(pcs), weight, raevbrn, raedyrs,
         r10sibs, edu, income_med, married, agefb, rabyear,
         raehsamp, raestrat, parent_weight)

r_parents <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ parent_weight, 
		nest = TRUE,
		data = rand |> drop_na(parent_weight) 
		)

rand <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ weight, 
		nest = TRUE,
		data = rand |> drop_na(weight) 
		)

n_white <- nrow(rand |> subset(ethnicity == "white"))
n_black <- nrow(rand |> subset(ethnicity == "black"))

# clean up cache so it doesn't get too big
rm(rand_orig, trk_orig, rands, rand_fam)
```

@hugh2022human explain patterns of natural selection on polygenic scores in the UK, using an economic theory of fertility derived from @becker1976child. The theory has two components.

1.  There is a trade-off between time spent working and raising children. This leads people with more human capital and higher expected wages to have fewer children.
2.  The trade-off is sharper for low-income people, people with low human capital, and single parents. As a result, natural selection is stronger among these groups.

The evidence for point 1 is that polygenic scores which correlate positively with human capital correlate negatively with number of children, i.e. they are being selected against. And vice versa, scores which correlate positively with human capital are being selected for. The evidence for point 2 is that correlations with number of children are larger and more significant among people with lower income, less education and single parents.

Here, I test the same theory in the US population, using the Health and Retirement Survey [@hrsrandfam2023; @hrsrand2023]. This gives an independent test of the theory. The HRS is more representative of the population than UK Biobank, which addresses one potential weakness of the previous paper. Also, the HRS provides precalculated polygenic scores [@hrspgs2020] for both black and (non-hispanic) white participants, so I can check whether the human capital theory of natural selection works in both these ethnicities.

Economic theory treats all humans as the same. Once you have controlled appropriately for people's preferences, resources and beliefs, there should be no difference between ethnicities. So, the economic theory of fertility predicts that patterns of natural selection should be the same in both white and black ethnic groups. Of course, ethnic groups may have different economic characteristics. Also, most of the polygenic scores were created using people of European ancestry. This means they are less predictive for people with African ancestry. If natural selection works via scores' correlation with phenotypes, then we would expect these correlations to be smaller among black people.

# Data

The HRS sample focuses on cohorts born between 1920 and 1960, but contains some younger and older participants. I include only male participants born before 1965 and female participants born before 1970, which guarantees that most will have completed their fertility by 2010.

TODO: I think for all these guys, the raevborn question will have been asked by the time they were indeed over 45/40. Double check.

The resulting sample contains `r n_white` genotyped white participants and `r n_black` genotyped black participants. Genotyping took place in 2006, 2008 and subsequent years. I discard obsolete PGS for which there is a newer, more accurate score targeting the same phenotype. I also discard PGS for number of children ever born (but keep scores for age at first birth).

PGS are rescaled to zero mean and unit variance within each ethnic group, so effect sizes are not directly comparable between ethnic groups, but are measured in standard deviations of the within-ethnic-group score. In all regressions using PGS, I control for ten principal components of the DNA array data.

I use realised fertility (number of children ever born) as the key dependent variable. I use this rather than relative lifetime reproductive success for ease of interpretation and because I don't have data for dates when children were born. My focus is on examining patterns of natural selection across PGS, rather than estimating their effects on PGS over time; raw fertility is good enough for this.

The HRS contains weights which match survey respondents to the US population. I use weights for the biomarker subsample (\*BIOWGTR in the HRS tracker file). Since half the sample enters the extended interview including biomarker data in each biannual survey, I weight individuals by either their 2010 weight or their 2012 weight. This maximizes the available sample of both black and white respondents, and should approximately match the US population of the sample cohorts between 2010 and 2012. Statistical tests are adjusted for clustering and stratification using the R "survey" package [@lumleysurvey2023].

# Results

```{r}
#| label: stat-regressions

# cache seems to cause trouble even with cache-lazy: FALSE 

tidy_pgs <- mod_pgs <- list()
tidy_pgs_ed <- mod_pgs_edyrs <- list()
tidy_pgs_sibs <- mod_pgs_sibs <- list()
tidy_pgs_x_ed <- mod_pgs_x_ed <- list()
tidy_pgs_x_inc <- mod_pgs_x_inc <- list()
tidy_pgs_x_mar <- mod_pgs_x_mar <- list()
tidy_pgs_x_agefb <- mod_pgs_x_agefb <- list()

cors_fert_edu <- tidy_pgs_joined <- list()
cors_sibs_edu <- list()
cor_fert_edu_phen <- list()

for (eth in eths) {
  r_eth <- rand |> subset(ethnicity == eth)
  r_parents_eth <- r_parents |> subset(ethnicity == eth)
  
  form_pgs <- map(pgs, \(x) reformulate(c(x, pcs), response = "raevbrn"))
  mod_pgs[[eth]] <- map(form_pgs, 
                        \(x) svyglm_quiet(x, r_eth)
                        )
  
  tidy_pgs[[eth]] <- mod_pgs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |> 
    list_rbind() |>
    filter(term %in% pgs)
  
  form_pgs_edyrs <- map(pgs, \(x) reformulate(c(x, pcs),
                                              response = "raedyrs"))
  mod_pgs_edyrs[[eth]] <- map(form_pgs_edyrs, 
                              \(x) svyglm_quiet(x, r_eth)
                              )
  
  tidy_pgs_ed[[eth]] <- mod_pgs_edyrs[[eth]] |>  
    map(broom::tidy) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  tidy_pgs_joined[[eth]] <- inner_join(tidy_pgs[[eth]], tidy_pgs_ed[[eth]],
                                by = join_by(term),
                                unmatched = "error",
                                suffix = c(".fert", ".edyrs"),
                                relationship = "one-to-one")
  cors_fert_edu[[eth]] <- cor(tidy_pgs_joined[[eth]]$estimate.edyrs, 
                     tidy_pgs_joined[[eth]]$estimate.fert)

  form_pgs_sibs <- map(pgs, 
                       \(x) reformulate(c(x, pcs), response = "r10sibs"))
  mod_pgs_sibs[[eth]] <- map(form_pgs_sibs,
                             \(x) svyglm_quiet(x, r_parents_eth))
  
  tidy_pgs_sibs[[eth]] <- mod_pgs_sibs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  cors_sibs_edu[[eth]] <- cor(tidy_pgs_sibs[[eth]]$estimate, 
                     tidy_pgs_ed[[eth]]$estimate)
  
  # the colon interaction estimates the effect separately within each group
  form_pgs_x_ed <- paste0(pgs, ":edu") |>
    map(\(x) reformulate(c(x, "edu", pcs), response = "raevbrn"))
  mod_pgs_x_ed[[eth]]  <-
    map(form_pgs_x_ed, 
        \(x) svyglm_quiet(x, r_eth)
        )
  
  tidy_pgs_x_ed[[eth]] <-
    map(mod_pgs_x_ed[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_ed[[eth]]) <- pgs
  tidy_pgs_x_ed[[eth]] <-
    list_rbind(tidy_pgs_x_ed[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "edu13-17", pcs)) |>
    mutate(edu = str_remove(term, ".*:"))
  
  form_pgs_x_inc <- paste0(pgs, ":income_med") |>
    map(\(x) reformulate(c(x, "income_med", pcs), response = "raevbrn"))
  mod_pgs_x_inc[[eth]]  <-
    map(form_pgs_x_inc, 
        \(x) svyglm_quiet(x, r_eth)
        )
  
  tidy_pgs_x_inc[[eth]] <-
    map(mod_pgs_x_inc[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_inc[[eth]]) <- pgs
  tidy_pgs_x_inc[[eth]] <-
    list_rbind(tidy_pgs_x_inc[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "income_medHigh", pcs)) |>
    mutate(income_med = str_remove(term, ".*:income_med"))
  
  
  form_pgs_x_mar <- paste0(pgs, ":married") |>
    map(\(x) reformulate(c(x, "married", pcs), response = "raevbrn"))
  mod_pgs_x_mar[[eth]]  <-
    map(form_pgs_x_mar, 
        \(x) svyglm_quiet(x, r_eth)
        )
  
  tidy_pgs_x_mar[[eth]] <-
    map(mod_pgs_x_mar[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_mar[[eth]]) <- pgs
  tidy_pgs_x_mar[[eth]] <-
    list_rbind(tidy_pgs_x_mar[[eth]], names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "marriedMarried", pcs)) |>
    mutate(
      married = str_remove(term, ".*:married")
    ) 
  
  form_pgs_x_agefb <- paste0(pgs, ":agefb") |>
    map(\(x) reformulate(c(x, "agefb", pcs), response = "raevbrn"))
  mod_pgs_x_agefb[[eth]]  <-
    map(form_pgs_x_agefb, 
        \(x) svyglm_quiet(x, r_eth)
        )
  
  tidy_pgs_x_agefb[[eth]] <-
    map(mod_pgs_x_agefb[[eth]], broom::tidy, conf.int = TRUE) |> 
    setNames(pgs) |> 
    list_rbind(names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "agefbHigh", pcs)) |>
    mutate(
      agefb = str_remove(term, ".*:agefb")
    ) 
  
  cor_fert_edu_phen[[eth]] <- 
    svyglm_quiet(raevbrn ~ raedyrs, r_eth) |> 
    coef() |> 
    pluck("raedyrs")
}


tidy_pgs_eth <- bind_rows(tidy_pgs,  .id = "ethnicity")

n_tests <- nrow(tidy_pgs_eth)
n_sig_bonf <- sum(tidy_pgs_eth$p.value < 0.05/n_tests)
if (n_sig_bonf != 0) stop("More/less than 0 score was Bonferroni significant")


```

Appendix @fig-fertility shows effect sizes of PGS correlations with realised fertility among each ethnic group. Standard errors are large because of the relatively low sample sizes, and no scores are significant at Bonferroni-corrected p \< 0.05/`r n_tests`. But I am most concerned with looking at patterns across scores rather than judging the significance of individual scores.

```{r}
#| label: stat-bootstraps
#| cache: true
#| cache-lazy: false

n_reps <- 599

calc_cors_edu <- function (weights, data, var) {
  coef_pgs_fert <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = var)) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  coef_pgs_edu <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "raedyrs")) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  cor(coef_pgs_edu, coef_pgs_fert)
}
  

cors_fert_edu <- cors_sibs_edu <- list()
for (eth in eths) {
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  r_parents_boot <- r_parents |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  
  cors_fert_edu[[eth]] <- 
    withReplicates(rand_boot, theta = calc_cors_edu, var = "raevbrn")
  cors_sibs_edu[[eth]] <- 
    withReplicates(r_parents_boot, theta = calc_cors_edu,var = "r10sibs")
}

tails_boot_fert <- map(cors_fert_edu, confint_workaround)

tails_boot_sibs <- map(cors_sibs_edu, confint_workaround)


stopifnot(significant(tails_boot_fert$white))
stopifnot(insignificant(tails_boot_fert$black))
stopifnot(all(map_lgl(tails_boot_sibs, insignificant)))
```

@fig-fertility-edu plots each PGS's correlation with fertility against its correlation with educational attainment. The relationship is negative among whites (correlation `r cors_fert_edu$white`, bootstrapped 95% C.I. `r tails_boot_fert$white[1]` to `r tails_boot_fert$white[2]`) and negative but insignificant among blacks (correlation `r cors_fert_edu$black`, bootstrapped 95% C.I. `r tails_boot_fert$black[1]` to `r tails_boot_fert$black[2]`). I use bootstraps so as to make inferences from the sample of individuals, rather than the "sample" of different PGS.

The relationship is imprecisely estimated in the smaller black sample, but it is also steeper. Put another way, if we measured PGS in units of "years of associated education", estimated selection effects would be larger among blacks than whites. If this holds in the population, one reason may be that the correlation between phenotypic years of education and fertility is larger for blacks than for whites. In bivariate regressions, an extra year of education reduces fertility by `r cor_fert_edu_phen$white` for whites and `r cor_fert_edu_phen$black` for blacks [cf. @goldscheider1969minority; @johnson1979minority; @yang2003big]. In turn, the simplest explanation for this fact would be point 2 of the theory. Because black people on average have lower incomes and fewer years of education, and are more likely to be single parents, the fertility-wage tradeoff is especially acute for them [cf. @maralani2013demography].

```{r}
#| label: fig-fertility-edu
#| fig-cap: |
#|   Scatterplot of PGS effect sizes on fertility and years of
#|   education. Controls include 10 principal components of genetic array
#|   data. Dashed lines show linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <- ggplot(tidy_pgs_joined[[eth]], aes(estimate.edyrs, estimate.fert)) +
          geom_hline(yintercept = 0, color = "grey80") +
          geom_vline(xintercept = 0, color = "grey80") +
          geom_point() +
          geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                      linetype = "dashed", colour = "red", linewidth = 0.5) +
          scale_y_continuous(breaks = seq(-0.35, 0.15, 0.05),
                             labels = scales::label_number(0.01)) +
          coord_cartesian(xlim = c(-.3, .75)) +
          theme_light() + 
          theme(panel.grid = element_blank()) +
          labs(
            title = titles[eth],
            x = "Effect on years of education",
            y = "Effect on realized fertility"
          )
  print(ggp)
}

# TODO: 3 scores are outliers among african-americans, with negative effects
# on fertility and education - kidney disease, including the trans-ethnic
# score, and PTSD estimated among european ancestry. Why?
```

```{r}
#| label: stat-siblings

tmp <- 
  tidy_pgs_sibs$black |> 
  inner_join(tidy_pgs_ed$black, 
             by = join_by(term), 
             suffix = c(".sibs", ".edyrs")) |> 
  filter(term != "GWAD2NA", term != "GWAD2WA")

cor_no_outliers <- cor(tmp$estimate.sibs, tmp$estimate.edyrs)
if (! cor_no_outliers < 0) stop("Correlation without outliers IS NOT neg.")
```

I can also examine natural selection in the previous generation, by regressing PGS on respondents' number of siblings (including dead siblings) in 2010. I reweight respondents by the reciprocal of their number of siblings, to account for parents of many siblings being more likely to be a parent of a respondent. Parents of no siblings cannot be included, so effect sizes are not comparable across the generations. Appendix @fig-siblings plots effects on number of siblings versus effects on years of education. Correlations are insignificant for both ethnic groups.

I next test part 2 of the theory more directly by interacting PGS with measures of education, income and marital status. Education is years of education, split at 12 years. Income is respondent's mean wage income over all surveys, residualized on a full set of birth year dummies, and median-split.

```{r}
#| label: stat-x-bootstraps
#| cache: true
#| cache-lazy: false

n_reps_x <- 99


calc_diff_cor_ed <- function (w, data, term) {
  groups <- switch(term,
                edu = c("0-12", "13-17"),
                income_med = c("Low", "High"),
                married = c("Other", "Married"),
                agefb = c("Low", "High"))
  groups <- paste0(":", term, groups) # colon for the cross term
  low_group <- groups[1]
  high_group <- groups[2]
  
  forms <- paste0(pgs, ":", term) |>
    map(\(x) reformulate(c(x, term, pcs), response = "raevbrn"))
  mods <- map(forms, \(x) lm(x, data, weights = w))
  cfs <- map(mods, coef)
  cfs_low <- map_dbl(cfs, \(x) x[str_detect(names(x), low_group)])
  cfs_high <- map_dbl(cfs, \(x) x[str_detect(names(x), high_group)])
  
  forms_ed <- paste0(pgs, ":", term)  |> 
    map(\(x) reformulate(c(x, term, pcs), response = "raedyrs"))
  mods_ed <- forms_ed |> map(\(x) lm(x, data, weights = w))
  cfs_ed <- map(mods_ed, coef)
  cfs_ed_low <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), low_group)])
  cfs_ed_high <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), high_group)])
  
  cor_ed_low <- cor(cfs_low, cfs_ed_low)
  cor_ed_high <- cor(cfs_high, cfs_ed_high)
  
  cor_ed_low - cor_ed_high
}

diff_cor_ed_ed <- diff_cor_ed_inc <- diff_cor_ed_mar <- diff_cor_ed_agefb <-
  list()

for (eth in eths) {
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_x)
  
  diff_cor_ed_ed[[eth]] <- 
    withReplicates(rand_boot, theta = calc_diff_cor_ed, term = "edu")
  diff_cor_ed_inc[[eth]] <- 
    withReplicates(rand_boot, theta = calc_diff_cor_ed, term = "income_med")
  diff_cor_ed_mar[[eth]] <- 
    withReplicates(rand_boot, theta = calc_diff_cor_ed, term = "married")
  diff_cor_ed_agefb[[eth]] <-
    withReplicates(rand_boot, theta = calc_diff_cor_ed, term = "agefb")
}


ci_ed <- map(diff_cor_ed_ed, confint_workaround)
ci_inc <- map(diff_cor_ed_inc, confint_workaround)
ci_mar <- map(diff_cor_ed_mar, confint_workaround)
ci_agefb <- map(diff_cor_ed_agefb, confint_workaround)


# TODO: does splitting by education to 12 and education 13-16 mechanically
#   cause a lower correlation with edyrs in the 13-16 group?
stopifnot(significant(ci_ed$white))
stopifnot(insignificant(ci_ed$black))
stopifnot(all(map_lgl(ci_inc, insignificant)))
stopifnot(all(map_lgl(ci_mar, insignificant)))
stopifnot(all(map_lgl(ci_agefb, insignificant)))

```

@fig-x-edu shows that for both whites and blacks, there is essentially no difference in the distribution of absolute effect sizes between respondents with more and less education. @fig-x-inc, on the other hand, shows that absolute effect sizes appear larger among lower-income respondents, for both whites and blacks. @fig-x-mar shows absolute effect sizes for respondents who were married in 2010 against all other statuses. Among blacks, effect sizes look similar across marital status, but among whites they are larger for unmarried respondents. @fig-x-agefb splits respondents by age at first birth (median within each ethnicity). There are no large differences between early and late parents. Note that the N is lower here due to missing values.

The economic theory implies that correlations between education and fertility should be higher for lower-income/education people, single parents and people who have children earlier.[^1] This in turn implies that correlations between PGS effects on education and on fertility should be higher among these groups. I test this with bootstraps, calculating effect sizes and correlations within each pair of groups, and taking the difference between them. Correlations are indeed higher among low- than high-education whites (bootstrapped C.I. for difference in correlations `r ci_ed$white[1]` to `r ci_ed$white[2]`) but for all other pairs of groups the difference is not significantly different from zero. In fact, the confidence intervals are so wide that we lack power to detect all but large differences.

[^1]: See @hugh2022human equation (6) and following.

```{r}
#| label: fig-x-edu
#| fig-cap: |
#|   Violin plots of polygenic score effects on fertility by education. 
#|   Effect sizes are
#|   absolute sizes of effects of a one standard deviation (within-ethnicity) 
#|   change of the PGS on fertility, controlling for 10 principal 
#|   components of genetic array data, estimated within the low/high
#|   education group. Lines show quartiles.


tidy_pgs_x_ed |> 
  list_rbind(names_to = "ethnicity") |> 
  mutate(
    Ethnicity = paste(titles[ethnicity], calc_n(mod_pgs_x_ed, ethnicity)),
    Education = str_remove(edu, "edu")
  ) |> 
  ggplot(aes(Education, abs(estimate), color = Education, fill = Education)) +
    geom_point(position = position_jitter(width = 0.05), alpha = 0.8) +
    geom_violin(alpha = 0.4, draw_quantiles = 1:3/4) +
    facet_wrap(vars(Ethnicity), scales = "free_y") +
    labs(
      x = "Years of education",
      y = "Absolute effect size"
    ) +
    theme_minimal() +
    theme(
      legend.position = "none"
    )
```

```{r}
#| label: fig-x-inc
#| fig-cap: |
#|   Violin plots of polygenic score effects on fertility by income. 
#|   Effect sizes are
#|   absolute sizes of effects of a one standard deviation (within-ethnicity) 
#|   change of the PGS on fertility, controlling for 10 principal 
#|   components of genetic array data, estimated within the low/high income
#|   group. Lines show quartiles.

tidy_pgs_x_inc |> 
  list_rbind(names_to = "ethnicity") |> 
  mutate(
    Ethnicity = paste(titles[ethnicity], calc_n(mod_pgs_x_inc, ethnicity)),
    Income = fct_relevel(income_med, c("Low", "High"))
  ) |> 
  ggplot(aes(Income, abs(estimate), color = Income, fill = Income)) +
    geom_point(position = position_jitter(width = 0.05), alpha = 0.8) +
    geom_violin(alpha = 0.4, draw_quantiles = 1:3/4) +
    facet_wrap(vars(Ethnicity), scales = "free_y") +
    labs(
      x = "Income",
      y = "Absolute effect size"
    ) +
    theme_minimal() +
    theme(
      legend.position = "none"
    )
```

```{r}
#| label: fig-x-mar
#| fig-cap: |
#|   Violin plots of polygenic score effects on fertility by marital status. 
#|   Effect sizes are
#|   absolute sizes of effects of a one standard deviation (within-ethnicity) 
#|   change of the PGS on fertility, controlling for 10 principal 
#|   components of genetic array data, estimated within the low/high income
#|   group. Lines show quartiles.

tidy_pgs_x_mar |> 
    list_rbind(names_to = "ethnicity") |> 
    mutate(
      Ethnicity = paste(titles[ethnicity], calc_n(mod_pgs_x_mar, ethnicity)),
      married = fct_relevel(married, "Other", "Married")
    ) |> 
    ggplot(aes(married, abs(estimate), color = married, fill = married)) +
      geom_point(position = position_jitter(width = 0.05), alpha = 0.8) +
      geom_violin(alpha = 0.4, draw_quantiles = 1:3/4) +
      facet_wrap(vars(Ethnicity), scales = "free_y") +
      labs(
          x = "Married",
          y = "Absolute effect size"
      ) +
      theme_minimal() +
      theme(
          legend.position = "none"
      )

```

```{r}
#| label: fig-x-agefb
#| fig-cap: |
#|   Violin plots of polygenic score effects on fertility by age at 
#|   first birth (median split). Effect sizes are
#|   absolute sizes of effects of a one standard deviation (within-ethnicity) 
#|   change of the PGS on fertility, controlling for 10 principal 
#|   components of genetic array data, estimated within the low/high income
#|   group. Lines show quartiles.

tidy_pgs_x_agefb |> 
    list_rbind(names_to = "ethnicity") |> 
    mutate(
     Ethnicity = paste(titles[ethnicity], calc_n(mod_pgs_x_agefb, ethnicity)),
      agefb = fct_relevel(agefb, "Low", "High")
    ) |> 
    ggplot(aes(agefb, abs(estimate), color = agefb, fill = agefb)) +
      geom_point(position = position_jitter(width = 0.05), alpha = 0.8) +
      geom_violin(alpha = 0.4, draw_quantiles = 1:3/4) +
      facet_wrap(vars(Ethnicity), scales = "free_y") +
      labs(
          x = "Age at first birth",
          y = "Absolute effect size"
      ) +
      theme_minimal() +
      theme(
          legend.position = "none"
      )

```

# Discussion

The results here provide qualified support for the economic theory of fertility as an explanation for contemporary natural selection in humans. PGS which predict less education are being selected for, and PGS which predict more education are being selected against. However, there is little evidence that PGS effects on fertility are larger, or more correlated with effects on education, among low-education or low-income individuals, unmarried parents, or younger parents. This is partly due to the low sample size. But in the UK, the between-group differences were large [@hugh2022human]; differences that big would surely have been visible in this data.

Lastly, the smaller black sample makes most tests inconclusive for this population. Most effect sizes, measured in within-ethnicity standard deviations, are larger among black people, which implies that the *proportional* effect of natural selection on PGS scores is larger in this subgroup. But since most PGS are also less predictive of their target phenotypes among black people, this fact is hard to interpret.

\FloatBarrier

# Appendix

## Acknowledgements

The HRS (Health and Retirement Study) is sponsored by the National Institute on Aging (grant number NIA U01AG009740) and is conducted by the University of Michigan.

## Figures

```{r}
#| label: fig-cohorts
#| fig-cap: Distribution of birth years for the sample

rand$variables |> 
    mutate(
      Ethnicity = fct_relevel(titles[ethnicity], "White", "Black")
    ) |> 
    ggplot(aes(rabyear, fill = Ethnicity)) + 
      geom_bar(position = "identity") +
      labs(x = "Birth year", y = "Count") +
      scale_fill_manual(values = c(Black = "orange2", White = "steelblue4")) +
      theme_minimal() +
      theme(legend.title = element_blank())  

```

```{r}
#| label: fig-fertility
#| fig-cap: |
#|  Effects of PGS on realized fertility. Values are partial correlations 
#|  of a one standard deviation (within ethnicity) change of the PGS with
#|  fertility, controlling for 10 principal components of genomic array 
#|  data. Scales differ between the two charts.
#| fig-height: 6

tidy_pgs_eth |>
  mutate(
    term = nice_names[term],
    term = fct_reorder(term, estimate, \(x) x[2]),
    ethnicity = ifelse(ethnicity == "white", "Whites (non-Hispanic)", "Blacks"),
    # hack to order scales separately from 
    # https://stackoverflow.com/questions/26238687/r-reorder-facet-wrapped-x-axis-with-free-x-in-ggplot2
    term_mangled = paste(ethnicity, term, sep = "//"),
    term_mangled = fct_reorder(term_mangled, estimate),
  ) |>
  ggplot(aes(estimate, term_mangled, color = ethnicity)) +
    geom_vline(xintercept = 0) +
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high),
                    position = position_dodge(width = 0.5), 
                    alpha = 0.8, size = 0.3) +
    facet_wrap(vars(ethnicity), scales = "free") +
    theme_light() + 
    scale_y_discrete(labels = \(x) str_remove(x, "^.*//")) +
    scale_color_manual(values = c("orange2", "seagreen")) +
    labs(
      x = "", y = "",
      title = "Effects of polygenic scores on fertility"
    ) +
    theme(
      panel.grid.major.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      legend.position = "none",
      axis.text.y = element_text(size = 7),
      strip.text = element_text(colour = "black", size = 10),
      strip.background = element_rect(fill = NA)
    )
```

```{r}
#| label: fig-siblings
#| fig-cap: |
#|   Scatterplot of PGS effect sizes on number of live siblings and years of
#|   education. Controls include 10 principal components of genetic array
#|   data. Dashed lines show linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <-  
    tidy_pgs_sibs[[eth]] |> 
    inner_join(tidy_pgs_ed[[eth]], 
               by = join_by(term), suffix = c(".sibs", ".edyrs")) |> 
    ggplot(aes(estimate.edyrs, estimate.sibs)) +
      geom_hline(yintercept = 0, color = "grey80") +
      geom_vline(xintercept = 0, color = "grey80") +
      geom_point() +
      geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                  linetype = "dashed", colour = "red", linewidth = 0.5) +
      coord_cartesian(xlim = c(-.3, .75)) +
      theme_light() + 
      theme(panel.grid = element_blank()) +
      labs(
          title = eth,
          x = "Effect on years of education",
          y = "Effect on number of siblings"
      )
  print(ggp)
}

```

\FloatBarrier

# Bibliography
