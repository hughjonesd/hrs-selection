---
title: "Natural selection in the Health and Retirement Study"
author: "David Hugh-Jones"
abstract: |
  I investigate natural selection on polygenic scores
  in the contemporary US, using the Health and Retirement Study. Results
  partially support the economic theory of fertility as an explanation for
  natural selection: among both white and black respondents,
  scores which correlate negatively (positively) with education are
  selected for (against). Selection coefficients are larger among low-income
  and unmarried parents, but not among younger parents or those with less 
  education.
date: "September 2023"
format: 
  pdf:
    keep-tex: true
    include-in-header:
      - text: |
          \usepackage{placeins}
    geometry:
    - top=2in
    - left=1.25in
    - right=1.25in
    - heightrounded
editor: visual
editor_options: 
  chunk_output_type: console
knitr:
  opts_chunk: 
    echo: false
bibliography: bibliography-hrs.bib
---

```{r}
#| label: setup


# TODO: ratio to family poverty threshold, h10inpovr
# TODO: I think for all these guys, the raevborn question will have been 
#.   asked by the time they were indeed over 45/40. Double check.

# Is ADHD reverse-coded? - Doesn't seem to be, correlates negatively
#       with income
# What about XDISORDER?
# ADHD doesn't seem to be. Nor does XDISORDER (correlates with e.g. r*depres)

options(digits = 3)
set.seed(271075)
knitr::knit_hooks$set("inline", 
  \(x) {
    if (! is.na(x <- suppressWarnings(as.numeric(x)))) {
      x <- prettyNum(formatC(x, digits = 3, format = "f"), ",")
    }
    x
  }
)


library(haven)
library(forcats)
library(dplyr, warn.conflicts = FALSE)
library(stringr)
library(purrr)
library(ggplot2)
library(tidyr)
library(santoku, warn.conflicts = FALSE) # masks tidyr::chop
 # masks dotchart:
suppressPackageStartupMessages(library(survey, warn.conflicts = FALSE))

nice_names <- c(
  SCZ         = "Schizophrenia",
  WC          = "Waist circ.",
  WHR         = "Waist-hip ratio",
  NEUROT      = "Neuroticism",
  WELLB       = "Well-being",
  DEPSYMP     = "Depr. symptoms",
  CD          = "Cor. art. disease",
  MI          = "Myoc. infarction",
  CORT        = "Cortisol",
  T2D         = "Type 2 diabetes",
  BIP         = "Bipolar",
  ADHD_PGC17  = "ADHD",
  XDISORDER   = "Cross-disorder",
  MENA        = "Age at menarche",
  MENO        = "Age at menopause",
  EXTRAVER    = "Extraversion",
  AUTISM      = "Autism",
  AB          = "Antisoc. behav.",
  OCD         = "OCD",
  AFBC        = "Age 1st birth combn",
  AFBF        = "Age 1st birth F",
  AFBM        = "Age 1st birth M",
  MDD2        = "Maj. depr. disorder",
  PTSDAA      = "PTSD Afr",
  PTSDEA      = "PTSD Eur",
  PTSDC       = "PTSD combined",
  HDL         = "HDL cholesterol",
  LDL         = "LDL cholesterol",
  TC          = "Total cholesterol",
  ANXFS       = "Anxiety CC", 
  ANXCC       = "Anxiety factor",
  BUN         = "Blood urea nitro.",
  BUNTE       = "Blood urea nitro. TE",
  CKD         = "Kidney disease",
  CKDTE       = "Kidney disease TE",
  DBP         = "Diastolic blood pr.",
  BMI2        = "BMI",
  HEIGHT2     = "Height",
  AI          = "Age smoking init.",
  CPD_GSCAN19 = "Cigs per day",
  DPW         = "Drinks per week",
  SC          = "Smoking cessation",
  SI          = "Smoking initiation",
  HTN         = "Hypertension",
  CANNABIS    = "Cannabis",
  GWAD2NA     = "Alzheimer's no APOE",
  ALZ_01AD2NA = "Alzheimer's p 0.01 no APOE",
  GWAD2WA     = "Alzheimer's",
  ALZ_01AD2WA = "Alzheimer's p 0.01",
  ALC         = "Alcohol dependence",
  PP          = "Pulse pressure",
  SBP         = "Systolic blood pr.",
  EGFR        = "Glom. filtr.",
  EGFRTE      = "Glom. filtr. TE",
  EA3         = "Educ. attainment",
  HBA1CAA     = "HbA1c Afr",
  HBA1CEA     = "HbA1c Eur",
  GCOG2       = "Gen. cognition"
)

eths <- c("white", "black")

titles <- c(white = "White", black = "Black")


shorten <- function (x) {
  x <- str_remove(x, "^(A4|E4)_")
  x_short <- str_remove(x, "_.*")

  duplicates <- table(x_short)
  duplicates <- names(duplicates)[duplicates > 1]
  x_short[x_short %in% duplicates] <- x[x_short %in% duplicates]

  x_short
}


calc_income <- function (x, eth) {
  x <- x |> filter(ethnicity == eth)
  ages <- x |> select(matches("r\\d+agey_e"))
  income <- x |> select(matches("r\\d+iearn"))
  income <- rowMeans(income, na.rm = TRUE)
  mod <- lm(income ~ factor(x$rabyear), weights = x$weight, na.action =
              na.exclude)
  income_r <- resid(mod)
  income_r <- income_r - min(income_r, na.rm = TRUE) + 1

  income_r
}


calc_n <- function (mods, eths = "white", format = "(N = %s)") {
  nobs <- map_dbl(eths, \(x) nobs(mods[[x]][[1]]) ) 
  if (! is.null(format)) nobs <- sprintf(format, nobs)
  names(nobs) <- eths
  nobs
}


# avoid warnings about zero weights
svyglm_quiet <- function (...) suppressWarnings(svyglm(...))


# for a confidence interval
significant <- function (x) {
  stopifnot(is.numeric(x), length(x) == 2)
  all(x < 0) || all(x > 0)
}


insignificant <- Negate(significant)


# rand HRS longit data. VERY BIG
# Done just once:
# rand_orig <- haven::read_dta("data/randhrs/randhrs1992_2020v1.dta")
# saveRDS(rand_orig, file = "data/randhrs/rand-orig.rds", compress = FALSE)
rand_orig <- readRDS("data/randhrs/rand-orig.rds")

# ragender: 1 male, 2 female
rand_orig <- filter(rand_orig, 
                    (rabyear <= 1965 & ragender == 1) |
                    (rabyear <= 1970 & ragender == 2))

# african ancestry
pgen4a <- haven::read_dta("data/PGENSCORE4r3/pgenscore4a_r.dta")
# european ancestry
pgen4e <- haven::read_dta("data/PGENSCORE4r3/pgenscore4e_r.dta")

# original HRS tracker file
trk_orig <- haven::read_dta("data/trk2020v3/trk2020tr_r.dta")
trk_weights <- trk_orig |> select(HHID, PN, matches("BIOWGTR"))

# rand family respondents file
# Done just once:
# rand_fam <- haven::read_dta(
#   "data/randhrsfam1992_2018v2_STATA/randhrsfamr1992_2018v2.dta")
# saveRDS(rand_fam, "data/randhrsfam1992_2018v2_STATA/rand_fam.rds")
rand_fam <- readRDS("data/randhrsfam1992_2018v2_STATA/rand_fam.rds")

# only selected columns to avoid creating suffixes when we join with
# rand.
# Age of oldest kid; grandchildren; num siblings who died
rand_fam <- rand_fam |> select(hhid, pn, h10ageokid, h10gkid, r10sbdied)

pgens <- list(white = pgen4e, black = pgen4a)

pcs <- c(paste0("PC1_5", LETTERS[1:5]), paste0("PC6_10", LETTERS[1:5]))

rands <- list()

for (eth in eths) {
  pgen <- pgens[[eth]]
  names(pgen) <- shorten(names(pgen))
  rands[[eth]] <- inner_join(rand_orig, pgen,
                     join_by(hhid, pn),
                     unmatched = "drop",
                     relationship = "one-to-one")
}

rand <- list_rbind(rands, names_to = "ethnicity")

pgs <- pgen4e |>
    rename_with(shorten) |> 
    # weird that I have to operate on whole df to use select semantics
    select(-hhid, -pn, -version,
           -matches("^PC\\d"),
           -matches("^NEB"), # number ever born
           # outdated, or EDU3 without 23andMe:
           -EDU2, -EDU3, -HEIGHT, -BMI,
           -AD, -AD2, -GENCOG, -EVRSMK, -LONG, -CPD_TAG10,
           -ADHD_PGC10, -MDD
           ) |>
    names()



rand <- rand |> left_join(rand_fam, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

# weighting
rand <- left_join(rand, trk_weights, by = join_by(hhid == HHID, pn == PN))
rand$weight <- ifelse(is.na(rand$MBIOWGTR), rand$NBIOWGTR, rand$MBIOWGTR)
# compensate for fecund parents more likely to have child in survey.
# we use living sibs rather than including dead sibs too here. I think that's
# the correct approach:
rand$parent_weight <- rand$weight / (rand$r10livsib + 1)

rand <- rand |>
  mutate(.by = rabyear, # calculate this pooling ethnicity
    mean_raevbrn = mean(raevbrn, na.rm = TRUE),
    rlrs = raevbrn/mean_raevbrn
  ) |>
  mutate(.by = ethnicity, # calculate these stats within-ethnicity
    income_resid = calc_income(rand, ethnicity[1]),
    income_resid = income_resid - min(income_resid, na.rm = TRUE) + 1,
    income_med = chop_equally(income_resid, 2, labels = c("Low", "High")),
    # as.numeric avoids haven.labelled issues:
    raedyrs = as.numeric(raedyrs),
    edu = chop(as.numeric(raedyrs), 13, lbl_discrete(symbol = "-")),
    # wave 10 is 2010
    # table(rands$white$r10mstat)
     # 1                 1.married
     # 2   2.married,spouse absent
     # 3               3.partnered
     # 4               4.separated
     # 5                5.divorced
     # 6      6.separated/divorced
     # 7                 7.widowed
     # 8           8.never married
    married = factor(r10mstat == 1, 
                     levels = c(FALSE, TRUE),
                     labels = c("Other", "Married")),
    r10sibs = r10livsib + 1, # n. sibs including oneself!
    agefb = r10agey_e - h10ageokid,
    agefb = ifelse(agefb < 12, NA_real_, agefb),
    agefb = chop_equally(agefb, 2, labels = c("Low", "High"))
  )

# two of four Alzheimer's variants with awkward names:
pgs <- str_replace(pgs, "^01", "ALZ_01")
names(rand) <- str_replace(names(rand), "^01", "ALZ_01")


rand <- rand |> 
  select(ethnicity, all_of(pgs), all_of(pcs), weight, raevbrn, rlrs,
         raedyrs, r10sibs, edu, income_med, married, agefb, rabyear,
         raehsamp, raestrat, parent_weight)

r_parents <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ parent_weight, 
		nest = TRUE,
		data = rand |> drop_na(parent_weight) 
		)

rand <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ weight, 
		nest = TRUE,
		data = rand |> drop_na(weight) 
		)

n_white <- nrow(rand |> subset(ethnicity == "white"))
n_black <- nrow(rand |> subset(ethnicity == "black"))

# clean up cache so it doesn't get too big
rm(rand_orig, trk_orig, rands, rand_fam)
```

@hugh2022human explain patterns of natural selection on polygenic scores in the UK, using an economic theory of fertility derived from @becker1976child. The theory has two components.

1.  There is a trade-off between time spent working and raising children. This leads people with more human capital and higher expected wages to have fewer children.
2.  The trade-off is sharper for low-income people, people with low human capital, and single parents. As a result, natural selection is stronger among these groups.

The evidence for point 1 is that polygenic scores which correlate positively with human capital correlate negatively with number of children, i.e. they are being selected against. And vice versa, scores which correlate positively with human capital are being selected for. The evidence for point 2 is that correlations with number of children are larger and more significant among people with lower income, less education and single parents.

Here, I make an independent test of the theory in the US population, using the Health and Retirement Survey [@hrsrandfam2023; @hrsrand2023]. The HRS is more representative of the population than UK Biobank, which addresses one potential weakness of the previous paper. The HRS also provides precalculated polygenic scores [@hrspgs2020] for both black and (non-hispanic) white participants, so I can check whether the human capital theory predicts patterns of natural selection in both these ethnicities.


# Data

The HRS sample focuses on cohorts born between 1920 and 1960, but contains some younger and older participants. I include only male participants born before 1965 and female participants born before 1970, which guarantees that most will have completed their fertility by 2010.

The resulting sample contains `r n_white` genotyped white participants and `r n_black` genotyped black participants. Genotyping took place in 2006, 2008 and subsequent years. I discard obsolete PGS for which there is a newer, more accurate score targeting the same phenotype. I also discard PGS for number of children ever born (but keep scores for age at first birth). This leaves a total of `r length(pgs)` scores.

PGS are rescaled to zero mean and unit variance within each ethnic group, so coefficient sizes are not directly comparable between ethnic groups, but are measured in standard deviations of the within-ethnic-group score. In all regressions using PGS, I control for ten within-ethnicity principal components of the DNA array data.

The key dependent variable is relative lifetime reproductive success (RLRS): number of children ever born, divided by mean number of children of people born in the same year. RLRS is calculated pooling ethnicities, i.e. treating them as members of the same biological population.

The HRS contains weights which match survey respondents to the US population. I use weights for the biomarker subsample (\*BIOWGTR in the HRS tracker file). Since half the sample enters the extended interview including biomarker data in each biannual survey, I weight individuals by either their 2010 weight or their 2012 weight. This maximizes the available sample of both black and white respondents, and should approximately match the US population of the sample cohorts between 2010 and 2012. Statistical tests are adjusted for clustering and stratification using the R "survey" package [@lumleysurvey2023].

# Results

```{r}
#| label: stat-regressions

# cache seems to cause trouble even with cache-lazy: FALSE 

tidy_pgs <- mod_pgs <- list()
tidy_pgs_ed <- mod_pgs_edyrs <- list()
tidy_pgs_sibs <- mod_pgs_sibs <- list()
tidy_pgs_x_ed <- mod_pgs_x_ed <- list()
tidy_pgs_x_inc <- mod_pgs_x_inc <- list()
tidy_pgs_x_mar <- mod_pgs_x_mar <- list()
tidy_pgs_x_agefb <- mod_pgs_x_agefb <- list()

coefs_fert_edu <- cors_fert_edu <- tidy_pgs_joined <- list()
cors_sibs_edu <- list()
cor_fert_edu_phen <- list()

for (eth in eths) {
  r_eth <- rand |> subset(ethnicity == eth)
  r_parents_eth <- r_parents |> subset(ethnicity == eth)
  
  form_pgs <- map(pgs, \(x) reformulate(c(x, pcs), response = "rlrs"))
  mod_pgs[[eth]] <- map(form_pgs, 
                               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs[[eth]] <- mod_pgs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |> 
    list_rbind() |>
    filter(term %in% pgs)
  
  form_pgs_edyrs <- map(pgs, \(x) reformulate(c(x, pcs),
                                              response = "raedyrs"))
  mod_pgs_edyrs[[eth]] <- map(form_pgs_edyrs, 
                                     \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_ed[[eth]] <- mod_pgs_edyrs[[eth]] |>  
    map(broom::tidy) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  tidy_pgs_joined[[eth]] <- inner_join(tidy_pgs[[eth]], tidy_pgs_ed[[eth]],
                                by = join_by(term),
                                unmatched = "error",
                                suffix = c(".fert", ".edyrs"),
                                relationship = "one-to-one")
  cors_fert_edu[[eth]] <- cor(tidy_pgs_joined[[eth]]$estimate.edyrs, 
                     tidy_pgs_joined[[eth]]$estimate.fert)
  coefs_fert_edu[[eth]] <- lm(estimate.fert ~ estimate.edyrs,
                              data = tidy_pgs_joined[[eth]]) |> 
                           coef() |> 
                           pluck("estimate.edyrs")
  
  form_pgs_sibs <- map(pgs, 
                       \(x) reformulate(c(x, pcs), response = "r10sibs"))
  mod_pgs_sibs[[eth]] <- map(form_pgs_sibs,
                                    \(x) svyglm_quiet(x, r_parents_eth))
  
  tidy_pgs_sibs[[eth]] <- mod_pgs_sibs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  cors_sibs_edu[[eth]] <- cor(tidy_pgs_sibs[[eth]]$estimate, 
                     tidy_pgs_ed[[eth]]$estimate)
  
  
  cor_fert_edu_phen[[eth]] <- 
    svyglm_quiet(rlrs ~ raedyrs, r_eth) |> 
    coef() |> 
    pluck("raedyrs")
}

# we only look at interactions among whites, the rest is pointless
for (eth in "white") {
  r_eth <- rand |> subset(ethnicity == eth)
  
  # the colon interaction estimates the effect separately within each group
  form_pgs_x_ed <- paste0(pgs, ":edu") |>
    map(\(x) reformulate(c(x, "edu", pcs), response = "rlrs"))
  mod_pgs_x_ed[[eth]]  <-
    map(form_pgs_x_ed, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_ed[[eth]] <-
    map(mod_pgs_x_ed[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_ed[[eth]]) <- pgs
  tidy_pgs_x_ed[[eth]] <-
    list_rbind(tidy_pgs_x_ed[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "edu13-17", pcs)) |>
    mutate(edu = str_remove(term, ".*:"))
  
  form_pgs_x_inc <- paste0(pgs, ":income_med") |>
    map(\(x) reformulate(c(x, "income_med", pcs), response = "rlrs"))
  mod_pgs_x_inc[[eth]]  <-
    map(form_pgs_x_inc, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_inc[[eth]] <-
    map(mod_pgs_x_inc[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_inc[[eth]]) <- pgs
  tidy_pgs_x_inc[[eth]] <-
    list_rbind(tidy_pgs_x_inc[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "income_medHigh", pcs)) |>
    mutate(income_med = str_remove(term, ".*:income_med"))
  
  form_pgs_x_mar <- paste0(pgs, ":married") |>
    map(\(x) reformulate(c(x, "married", pcs), response = "rlrs"))
  mod_pgs_x_mar[[eth]]  <-
    map(form_pgs_x_mar, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_mar[[eth]] <-
    map(mod_pgs_x_mar[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_mar[[eth]]) <- pgs
  tidy_pgs_x_mar[[eth]] <-
    list_rbind(tidy_pgs_x_mar[[eth]], names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "marriedMarried", pcs)) |>
    mutate(
      married = str_remove(term, ".*:married")
    ) 
  
  form_pgs_x_agefb <- paste0(pgs, ":agefb") |>
    map(\(x) reformulate(c(x, "agefb", pcs), response = "rlrs"))
  mod_pgs_x_agefb[[eth]]  <-
    map(form_pgs_x_agefb, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_agefb[[eth]] <-
    map(mod_pgs_x_agefb[[eth]], broom::tidy, conf.int = TRUE) |> 
    setNames(pgs) |> 
    list_rbind(names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "agefbHigh", pcs)) |>
    mutate(
      agefb = str_remove(term, ".*:agefb")
    ) 
}

tidy_pgs_eth <- list_rbind(tidy_pgs)
n_tests <- nrow(tidy_pgs_eth)
n_sig_bonf <- sum(tidy_pgs_eth$p.value < 0.05/n_tests)

```

```{r}
#| label: stat-bootstrap-eth-cor
#| cache: true
#| cache-lazy: false
#| eval: false

# I don't mention this below so turning it off for now
# TODO: should I mention it? It's a low correlation.

n_reps_eth_diff <- 99
rand_boot <- rand |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_eth_diff)


calc_eth_cor <- function (weights, data) {
  coef_pgs_white <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "white")) |> 
        map2_dbl(pgs, \(x, y) coef(x)[[y]])
  coef_pgs_black <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "black")) |> 
        map2_dbl(pgs, \(x, y) coef(x)[[y]])
  
  c(cor = cor(coef_pgs_black, coef_pgs_white))
}


cor_eths <- cor(tidy_pgs$white$estimate, tidy_pgs$black$estimate)
cor_eths_boot <- withReplicates(rand_boot, theta = calc_eth_cor)
ci_eths <- confint(cor_eths_boot)[1,]
```

I estimated coefficients of PGS on RLRS among black and white respondents separately. These are not meant to identify causal effects; recall that natural selection involves correlation, not necessarily causation, between selected characteristics and fertility. Appendix @fig-rlrs shows coefficients for white respondents only; power is too low for individual PGS estimates to be informative in the black sample. Standard errors are large because of the relatively low sample sizes, and only `r n_sig_bonf` score is significant at Bonferroni-corrected p \< 0.05/`r n_tests`. But I am most concerned with looking at patterns across scores rather than judging the significance of individual scores.



```{r}
#| label: stat-bootstraps
#| cache: true
#| cache-lazy: false
#| cache-comments: false


# Not sure this actually does anything :-)
old_opts <- options(survey.multicore = TRUE) 

# The large n_reps is to get an accurate upper tail on the black sample, 
# since it is close to 0:
n_reps <- 599

calc_cors_edu <- function (weights, data, var) {
  coef_pgs_fert <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = var)) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  coef_pgs_edu <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "raedyrs")) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  c(
    cor = cor(coef_pgs_edu, coef_pgs_fert),
    coef = coef(lm(coef_pgs_fert ~ coef_pgs_edu))["coef_pgs_edu"]
  )
}
  

cors_fert_edu <- cors_sibs_edu <- list()
for (eth in eths) {
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  r_parents_boot <- r_parents |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  
  cors_fert_edu[[eth]] <- 
    withReplicates(rand_boot, theta = calc_cors_edu, var = "rlrs")
  cors_sibs_edu[[eth]] <- 
    withReplicates(r_parents_boot, theta = calc_cors_edu, var = "r10sibs")
}

options(old_opts)
```

```{r}
#| label: stat-bootstrap-eth-diff
#| eval: false

# this was an attempt to see if black coefs were larger in abs size than
# white coefs. Results were always absolutely insignificant (and conf
# intervals too wide to be informative).

n_reps_eth_diff <- 99
rand_boot <- rand |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_eth_diff)


calc_eth_diff <- function (weights, data) {
  coef_pgs_white <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "white")) |> 
        map_dbl(\(x) coef(x)[[2]])
  coef_pgs_black <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "black")) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  # this is positive if white was "bigger" than black taking the white sign 
  # as the correct sign. Negative if b was "bigger"  than w.
  diff_coefs <- (coef_pgs_white - coef_pgs_black)*sign(coef_pgs_white)
  names(diff_coefs) <- pgs
  c(diff = mean(diff_coefs))
}

diff_eths <- withReplicates(rand_boot, theta = calc_eth_diff)
```

```{r}
#| label: stat-post-bootstraps

# separate so we don't interfere with the bootstrap cache

ci_boot_fert <- map(cors_fert_edu, \(x) confint(x)[1,])
ci_boot_sibs <- map(cors_sibs_edu, \(x) confint(x)[1,])

ci_boot_fert_lm <- map(cors_fert_edu, \(x) confint(x)[2,])
ci_boot_sibs_lm <- map(cors_sibs_edu, \(x) confint(x)[2,])

if (insignificant(ci_boot_fert$white)) warning("ci_boot_fert$white insignificant")
if (! insignificant(ci_boot_fert$black)) warning("ci_boot_fert$black significant")
if (significant(ci_boot_sibs$white)) warning("ci_boot_sibs$white significant")
if (significant(ci_boot_sibs$black)) warning("ci_boot_sibs$black significant")
```

@fig-rlrs-edu plots each PGS's partial correlation with RLRS against its partial correlation with educational attainment. The relationship is negative among whites (correlation `r cors_fert_edu$white[1]`, bootstrapped 95% C.I. `r ci_boot_fert$white[1]` to `r ci_boot_fert$white[2]`) and negative but insignificant among blacks (correlation `r cors_fert_edu$black[1]`, bootstrapped 95% C.I. `r ci_boot_fert$black[1]` to `r ci_boot_fert$black[2]`). Bootstraps are used so as to make inferences from the sample of respondents (the different PGS are not a "sample" of anything).

```{r}
#| label: fig-rlrs-edu
#| fig-cap: |
#|   Scatterplot of PGS regression coefficients on RLRS and years of
#|   education. Controls include 10 principal components of genetic array
#|   data. Dashed lines show linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <- ggplot(tidy_pgs_joined[[eth]], aes(estimate.edyrs, estimate.fert)) +
          geom_hline(yintercept = 0, color = "grey80") +
          geom_vline(xintercept = 0, color = "grey80") +
          geom_point() +
          geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                      linetype = "dashed", colour = "red", linewidth = 0.5) +
          scale_y_continuous(breaks = seq(-0.35, 0.15, 0.05),
                             labels = scales::label_number(0.01)) +
          coord_cartesian(xlim = c(-.3, .75)) +
          theme_light() + 
          theme(panel.grid = element_blank()) +
          labs(
            title = titles[eth],
            x = "Coefficient on years of education",
            y = "Coefficient on RLRS"
          )
  print(ggp)
}

# TODO: 3 scores are outliers among african-americans, with negative effects
# on fertility and education - kidney disease, including the trans-ethnic
# score, and PTSD estimated among european ancestry. Why?
```

```{r}
#| label: stat-siblings

tmp <- 
  tidy_pgs_sibs$black |> 
  inner_join(tidy_pgs_ed$black, 
             by = join_by(term), 
             suffix = c(".sibs", ".edyrs")) |> 
  filter(term != "GWAD2NA", term != "GWAD2WA")

cor_no_outliers <- cor(tmp$estimate.sibs, tmp$estimate.edyrs)
if (! cor_no_outliers < 0) stop("Correlation without outliers IS NOT neg.")
```

I can also examine natural selection in the previous generation, by regressing PGS on respondents' number of living siblings in 2010. (Data for dead siblings has too many missing values to use.) I reweight respondents by the reciprocal of their number of siblings, to account for parents of many siblings being more likely to be a parent of a respondent. Parents of no siblings cannot be included, so coefficient sizes are not comparable across the generations. Appendix @fig-siblings plots coefficients on number of siblings versus coefficients on years of education. Correlations are insignificant for both ethnic groups, although note that standard errors are large (whites: correlation `r cors_sibs_edu$white[1]`, bootstrapped 95% C.I. `r ci_boot_sibs$white[1]` to `r ci_boot_sibs$white[2]`; blacks: correlation `r cors_sibs_edu$black[1]`, bootstrapped 95% C.I. `r ci_boot_sibs$black[1]` to `r ci_boot_sibs$black[2]`).



I next test part 2 of the theory more directly by interacting PGS with measures of education, income, marital status, and age at first birth. Education is years of education, split at 12 years. Income is respondent's mean wage income over all surveys, residualized on a full set of birth year dummies, and median-split. From here on I only use the white subsample: there are too few black respondents to be informative.

```{r}
#| label: stat-x-bootstrap-cors
#| cache: true
#| cache-lazy: false
#| eval: false

old_opts <- options(survey.multicore = TRUE) 

# all confindence intervals were too wide to be informative
n_reps_x <- 99

calc_diff_cor_ed <- function (w, data, term) {
  groups <- switch(term,
                edu = c("0-12", "13-17"),
                income_med = c("Low", "High"),
                married = c("Other", "Married"),
                agefb = c("Low", "High"))
  groups <- paste0(":", term, groups) # colon for the cross term
  low_group <- groups[1]
  high_group <- groups[2]
  
  forms <- paste0(pgs, ":", term) |>
    map(\(x) reformulate(c(x, term, pcs), response = "rlrs"))
  mods <- map(forms, \(x) lm(x, data, weights = w))
  cfs <- map(mods, coef)
  cfs_low <- map_dbl(cfs, \(x) x[str_detect(names(x), low_group)])
  cfs_high <- map_dbl(cfs, \(x) x[str_detect(names(x), high_group)])
  
  forms_ed <- paste0(pgs, ":", term)  |> 
    map(\(x) reformulate(c(x, term, pcs), response = "raedyrs"))
  mods_ed <- forms_ed |> map(\(x) lm(x, data, weights = w))
  cfs_ed <- map(mods_ed, coef)
  cfs_ed_low <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), low_group)])
  cfs_ed_high <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), high_group)])
  
  cor_ed_low <- cor(cfs_low, cfs_ed_low)
  cor_ed_high <- cor(cfs_high, cfs_ed_high)
  
  c(low = cor_ed_low, high = cor_ed_high, diff = cor_ed_low - cor_ed_high)
}

diff_cor_ed <- ci <- est <- tbl <- list()

terms <- c("edu", "income_med", "married", "agefb")
for (eth in eths) {
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_x)
  
  for (term in terms) {
    diff_cor_ed[[eth]][[term]] <- 
      withReplicates(rand_boot, theta = calc_diff_cor_ed, term = term)  
    ci[[eth]][[term]] <- confint(diff_cor_ed[[eth]][[term]])
    est[[eth]][[term]] <- as.numeric(diff_cor_ed[[eth]][[term]])
  }
}

options(old_opts)


```

```{r}
#| label: stat-x-bootstrap-effect-size
#| cache: true
#| cache-lazy: false
#| cache-comments: false

old_opts <- options(survey.multicore = TRUE) 

n_reps_x_es <- 99

calc_diff_effect_size <- function (w, data, term) {
  groups <- switch(term,
                edu = c("0-12", "13-17"),
                income_med = c("Low", "High"),
                married = c("Other", "Married"),
                agefb = c("Low", "High"))
  groups <- paste0(":", term, groups) # colon for the cross term
  low_group <- groups[1]
  high_group <- groups[2]
  
  forms <- paste0(pgs, ":", term) |>
    map(\(x) reformulate(c(x, term, pcs), response = "rlrs"))
  mods <- map(forms, \(x) lm(x, data, weights = w))
  cfs <- map(mods, coef)
  cfs_low <- map_dbl(cfs, \(x) x[str_detect(names(x), low_group)])
  cfs_high <- map_dbl(cfs, \(x) x[str_detect(names(x), high_group)])
  
  abs_eff_low <- mean(abs(cfs_low))
  abs_eff_high <- mean(abs(cfs_high))
  diff_abs_eff <- abs_eff_low - abs_eff_high
  c(low = abs_eff_low, high = abs_eff_high, diff = diff_abs_eff)
}


diff_effect_size <- ci <- est <- tbl <- list()

terms <- c("edu", "income_med", "married", "agefb")

rand_boot <- rand |> 
  subset(ethnicity == "white") |> 
  as.svrepdesign(type = "bootstrap", replicates = n_reps_x_es)

for (term in terms) {
  diff_effect_size[[term]] <- 
    withReplicates(rand_boot, theta = calc_diff_effect_size, term = term)  
  ci[[term]] <- confint(diff_effect_size[[term]])
  est[[term]] <- as.numeric(diff_effect_size[[term]])
  tbl[[term]] <- sprintf("%.3f (%.3f to %.3f)", est[[term]], 
                         ci[[term]][, 1], ci[[term]][, 2])
}

options(old_opts)

```

```{r}
#| label: stat-agefb-bootstrap

n_reps_agefb <- 9
calc_cor_agefb <- function (w, data) {
  forms <- pgs |> map(\(x) reformulate(c(x, pcs), response = "raevbrn"))
  mods_low <- map(forms, \(x) lm(x, data, subset = agefb == "Low",
                                 weights = w))
  mods_high <- map(forms, \(x) lm(x, data, subset = agefb == "High",
                                  weights = w))
  coefs_low <- map2_dbl(mods_low, pgs, \(x, y) coef(x)[[y]])
  coefs_high <- map2_dbl(mods_high, pgs, \(x, y) coef(x)[[y]])
  
  c(
    cor = cor(coefs_low, coefs_high), 
    discordant = sum(sign(coefs_low) != sign(coefs_high)) # discordant pairs
  )
}

rand_boot <- rand |> 
  subset(ethnicity == "white") |> 
  as.svrepdesign(type = "bootstrap", replicates = n_reps_agefb)

cor_agefb <- withReplicates(rand_boot, theta = calc_cor_agefb)

stopifnot(insignificant(confint(cor_agefb)[1,]))
ci_discordant <- confint(cor_agefb)[2,]
# significantly different from 1/2?
stopifnot(ci_discordant[1] <= length(pgs)/2 && 
            ci_discordant[2] >= length(pgs)/2)

```

```{r}
#| label: stat-post-x-bootstrap

stopifnot(insignificant(ci$edu[3,]))
stopifnot(significant(ci$income_med[3,]))
stopifnot(significant(ci$married[3,]))
stopifnot(insignificant(ci$agefb[3,]))

tidy_agefb_wide <- tidy_pgs_x_agefb$white |> 
  pivot_wider(id_cols = pgs, names_from = agefb, values_from = estimate)

cor_agefb <- cor(tidy_agefb_wide$Low, tidy_agefb_wide$High)
n_discordant <- sum(sign(tidy_agefb_wide$Low) != sign(tidy_agefb_wide$High))
```

Appendix @fig-x-edu shows essentially no difference in the distribution of absolute coefficient sizes between respondents with more and less education. Appendix @fig-x-inc, on the other hand, shows that coefficients appear larger among lower-income respondents. Appendix @fig-x-mar shows absolute coefficients for respondents who were married in 2010 against all other statuses. Coefficients appear larger for unmarried respondents. 

Appendix @fig-x-agefb splits respondents by age at first birth (median within each ethnicity). There are no large differences between younger and older parents. As in the UK Biobank sample, correlations of PGS coefficients between younger and older parents are negative (`r cor_agefb`), and for `r n_discordant` out of `r length(pgs)` PGS, coefficients have opposite signs. However, in bootstraps, these statistics are not significantly different from 0 and `r length(pgs)/2` respectively. Note that the N is lower here due to missing values. 

@tbl-x-bootstraps shows means and 95% confidence intervals for mean absolute coefficient sizes in each pair of groups, and the difference between them, using bootstraps. Differences for income and marriage are significant.

|               | Low group             | High group            | Difference            |
|------------------|------------------|------------------|------------------|
| Education     | `r tbl$edu[1]`        | `r tbl$edu[2]`        | `r tbl$edu[3]`        |
| Income        | `r tbl$income_med[1]` | `r tbl$income_med[2]` | `r tbl$income_med[3]` |
| Marriage      | `r tbl$married[1]`    | `r tbl$married[2]`    | `r tbl$married[3]`    |
| Age 1st birth | `r tbl$agefb[1]`      | `r tbl$agefb[2]`      | `r tbl$agefb[3]`      |

: Bootstrap estimates and 95% confidence intervals for mean absolute coefficients of PGS on RLRS in "low" and "high" groups among white respondents. Groups are: 0-12 years education vs. 13-17 years; below vs. above median income; all others vs. married; below vs. above median age at first birth. `r n_reps_x_es` bootstraps. {#tbl-x-bootstraps tbl-colwidths="[16,28,28,28]"}

The economic theory of fertility in @hugh2022human implies that correlations between education and RLRS should be more negative for lower-income/education people, single parents and people who have children earlier.[^2] This in turn implies that correlations between PGS coefficients on education and on RLRS should be more negative among these groups. I tested this with bootstraps, but confidence intervals were always too wide to be informative.

[^2]: See @hugh2022human equation (6) and following.

# Discussion

The results here provide qualified support for the economic theory of fertility as an explanation for contemporary natural selection in humans. PGS which predict less education are being selected for, and PGS which predict more education are being selected against. PGS coefficients on RLRS also appear larger for low-income groups and unmarried respondents. But there is little evidence for larger coefficients among people with lower education, or younger parents. This may be due to the low sample size. But in the UK, the between-group differences were large [@hugh2022human]; differences that big would surely have been visible here. Lastly, the smaller black sample makes most tests inconclusive for this population: I can only say that the data do not reject a negative association between PGS correlations with RLRS and with education.

# Appendix

## Acknowledgements

The HRS (Health and Retirement Study) is sponsored by the National Institute on Aging (grant number NIA U01AG009740) and is conducted by the University of Michigan.

## Figures

```{r}
#| label: fig-cohorts
#| fig-cap: Distribution of birth years for the sample

rand$variables |> 
    mutate(
      Ethnicity = fct_relevel(titles[ethnicity], "White", "Black")
    ) |> 
    ggplot(aes(rabyear, fill = Ethnicity)) + 
      geom_bar(position = "identity") +
      labs(x = "Birth year", y = "Count") +
      scale_fill_manual(values = c(Black = "orange2", White = "steelblue4")) +
      theme_minimal() +
      theme(legend.title = element_blank())  

```

```{r}
#| label: fig-rlrs
#| fig-cap: |
#|  Coefficients of PGS on RLRS among white respondents, controlling for 10
#|  principal components of
#|  genomic array data. Lines are 95% confidence intervals.
#| fig-height: 6


tidy_pgs$white |>
  mutate(
    term = nice_names[term],
    term = fct_reorder(term, estimate)
  ) |>
  ggplot(aes(estimate, term)) +
    geom_vline(xintercept = 0) +
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high), size = 0.3) +
    theme_light() + 
    labs(
      x = "", y = "",
      title = "Coefficients of polygenic scores on RLRS"
    ) +
    theme(
      axis.text.y = element_text(size = 7),
      panel.grid.major.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      legend.position = "none"
    )
```

```{r}
#| label: fig-siblings
#| fig-cap: |
#|   Scatterplot of PGS coefficients on number of live siblings and years of
#|   education. Controls include 10 principal components of genetic array
#|   data. Dashed lines show linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <-  
    tidy_pgs_sibs[[eth]] |> 
    inner_join(tidy_pgs_ed[[eth]], 
               by = join_by(term), suffix = c(".sibs", ".edyrs")) |> 
    ggplot(aes(estimate.edyrs, estimate.sibs)) +
      geom_hline(yintercept = 0, color = "grey80") +
      geom_vline(xintercept = 0, color = "grey80") +
      geom_point() +
      geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                  linetype = "dashed", colour = "red", linewidth = 0.5) +
      coord_cartesian(xlim = c(-.3, .75)) +
      theme_light() + 
      theme(panel.grid = element_blank()) +
      labs(
          title = eth,
          x = "Coefficient on years of education",
          y = "Coefficient on number of siblings"
      )
  print(ggp)
}

```

```{r}
#| label: prog-x-plots

geom_x_boxplot <- geom_boxplot(color = "grey50", outlier.shape = NA)
geom_x_point <- geom_point(aes(shape = pgs=="EA3"), 
                           position = position_jitter(width = 0.03), 
                           alpha = 0.5) 

themes_x <- theme_minimal() +
      theme(
          legend.position = "none",
          panel.grid.major.x = element_blank()
      ) 
```

```{r}
#| label: fig-x-edu
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within the low/high
#|   education group. Boxes show quartiles. 

tidy_pgs_x_ed$white |> 
  mutate(
    Education = str_remove(edu, "edu")
  ) |> 
  ggplot(aes(Education, abs(estimate), color = Education)) +
    geom_x_boxplot + geom_x_point +
    labs(
      x = "Years of education",
      y = "Absolute coefficient",
      title = paste("PGS coefficients on RLRS by education", 
                    calc_n(mod_pgs_x_ed))
    ) +
    themes_x
```

```{r}
#| label: fig-x-inc
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within the below/above
#|   median income group. Boxes show quartiles.

tidy_pgs_x_inc$white |> 
  mutate(
    Income = fct_relevel(income_med, c("Low", "High"))
  ) |> 
  ggplot(aes(Income, abs(estimate), color = Income)) +
    geom_x_boxplot + geom_x_point +
    labs(
      x = "Income",
      y = "Absolute coefficient",
      title = paste("PGS coefficients on RLRS by income", 
                    calc_n(mod_pgs_x_inc))
    ) +
    themes_x
```

```{r}
#| label: fig-x-mar
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within married 
#|   and other respondents. Boxes show quartiles.

tidy_pgs_x_mar$white |> 
    mutate(
      married = fct_relevel(married, "Other", "Married")
    ) |> 
    ggplot(aes(married, abs(estimate), color = married)) +
      geom_x_boxplot + geom_x_point +
      labs(
          x = "Married",
          y = "Absolute coefficient",
          title = paste("PGS coefficients on RLRS by marital status", 
                        calc_n(mod_pgs_x_mar))
      ) +
      themes_x

```

```{r}
#| label: fig-x-agefb
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within below/above
#|   median age at first birth respondents. Boxes show quartiles.

tidy_pgs_x_agefb$white |> 
    mutate(
      agefb = fct_relevel(agefb, "Low", "High")
    ) |> 
    ggplot(aes(agefb, abs(estimate), color = agefb)) +
      geom_x_boxplot + geom_x_point +
      labs(
          x = "Age at first birth",
          y = "Absolute coefficient",
          title = paste("PGS coefficients on RLRS by age at first birth", 
                        calc_n(mod_pgs_x_agefb))
      ) +
      themes_x

```

\FloatBarrier

# Bibliography
