---
title: "Natural selection in the Health and Retirement Study"
author: "David Hugh-Jones"
abstract: |
  I investigate natural selection on polygenic scores
  in the contemporary US, using the Health and Retirement Study. Results
  partially support the economic theory of fertility as an explanation for
  natural selection: among both white and black respondents,
  scores which correlate negatively (positively) with education are
  selected for (against). Selection coefficients are larger among low-income
  and unmarried parents, but not among younger parents or those with less 
  education. I also estimate effect sizes corrected for noise in the 
  polygenic scores. 
date: "September 2023"
format: 
  pdf:
    keep-tex: true
    include-in-header:
      - text: |
          \usepackage{placeins}
    geometry:
    - top=2in
    - left=1.25in
    - right=1.25in
    - heightrounded
editor: visual
editor_options: 
  chunk_output_type: console
knitr:
  opts_chunk: 
    echo: false
bibliography: bibliography-hrs.bib
---

```{r}
#| label: setup


# TODO: ratio to family poverty threshold, h10inpovr
# TODO: I think for all these guys, the raevborn question will have been 
#.   asked by the time they were indeed over 45/40. Double check.

# Is ADHD reverse-coded? - Doesn't seem to be, correlates negatively
#       with income
# What about XDISORDER?
# ADHD doesn't seem to be. Nor does XDISORDER (correlates with e.g. r*depres)

options(digits = 3)
set.seed(271075)

library(tibble)
library(haven)
library(forcats)
library(dplyr, warn.conflicts = FALSE)
library(stringr)
library(purrr)
library(carData)
library(car, warn.conflicts = FALSE) # masks some
library(ggplot2)
library(tidyr)
library(santoku, warn.conflicts = FALSE) # masks tidyr::chop
 # masks dotchart:
suppressPackageStartupMessages(library(survey, warn.conflicts = FALSE))

knitr::knit_hooks$set("inline", 
  \(x) {
    if (! is.na(x <- suppressWarnings(as.numeric(x)))) {
      x <- prettyNum(formatC(x, digits = 3, format = "f"), ",")
    }
    x
  }
)

nice_names <- c(
  SCZ         = "Schizophrenia",
  WC          = "Waist circ.",
  WHR         = "Waist-hip ratio",
  NEUROT      = "Neuroticism",
  WELLB       = "Well-being",
  DEPSYMP     = "Depr. symptoms",
  CD          = "Cor. art. disease",
  MI          = "Myoc. infarction",
  CORT        = "Cortisol",
  T2D         = "Type 2 diabetes",
  BIP         = "Bipolar",
  ADHD_PGC17  = "ADHD",
  XDISORDER   = "Cross-disorder",
  MENA        = "Age at menarche",
  MENO        = "Age at menopause",
  EXTRAVER    = "Extraversion",
  AUTISM      = "Autism",
  AB          = "Antisoc. behav.",
  OCD         = "OCD",
  AFBC        = "Age 1st birth combn",
  AFBF        = "Age 1st birth F",
  AFBM        = "Age 1st birth M",
  MDD2        = "Maj. depr. disorder",
  PTSDAA      = "PTSD Afr",
  PTSDEA      = "PTSD Eur",
  PTSDC       = "PTSD combined",
  HDL         = "HDL cholesterol",
  LDL         = "LDL cholesterol",
  TC          = "Total cholesterol",
  ANXFS       = "Anxiety factor", 
  ANXCC       = "Anxiety case-control",
  BUN         = "Blood urea nitro.",
  BUNTE       = "Blood urea nitro. TE",
  CKD         = "Kidney disease",
  CKDTE       = "Kidney disease TE",
  DBP         = "Diastolic blood pr.",
  BMI2        = "BMI",
  HEIGHT2     = "Height",
  AI          = "Age smoking init.",
  CPD_GSCAN19 = "Cigs per day",
  DPW         = "Drinks per week",
  SC          = "Smoking cessation",
  SI          = "Smoking initiation",
  HTN         = "Hypertension",
  CANNABIS    = "Cannabis",
  GWAD2NA     = "Alzheimer's no APOE",
  ALZ_01AD2NA = "Alzheimer's p 0.01 no APOE",
  GWAD2WA     = "Alzheimer's",
  ALZ_01AD2WA = "Alzheimer's p 0.01",
  ALC         = "Alcohol dependence",
  PP          = "Pulse pressure",
  SBP         = "Systolic blood pr.",
  EGFR        = "Glom. filtr.",
  EGFRTE      = "Glom. filtr. TE",
  EA3         = "Educ. attainment",
  HBA1CAA     = "HbA1c Afr",
  HBA1CEA     = "HbA1c Eur",
  GCOG2       = "Gen. cognition"
)

eths <- c("white", "black")

titles <- c(white = "White", black = "Black")


shorten <- function (x) {
  x <- str_remove(x, "^(A4|E4)_")
  x_short <- str_remove(x, "_.*")

  duplicates <- table(x_short)
  duplicates <- names(duplicates)[duplicates > 1]
  x_short[x_short %in% duplicates] <- x[x_short %in% duplicates]

  x_short <- str_replace(x_short, "^01", "ALZ_01") # two alzheimer's variants
  x_short
}


calc_income <- function (x, eth) {
  x <- x |> filter(ethnicity == eth)
  ages <- x |> select(matches("r\\d+agey_e"))
  income <- x |> select(matches("r\\d+iearn"))
  income <- rowMeans(income, na.rm = TRUE)
  mod <- lm(income ~ factor(x$rabyear), weights = x$weight, na.action =
              na.exclude)
  income_r <- resid(mod)
  income_r <- income_r - min(income_r, na.rm = TRUE) + 1

  income_r
}


calc_n <- function (mods, eths = "white", format = "(N = %s)") {
  nobs <- map_dbl(eths, \(x) nobs(mods[[x]][[1]]) ) 
  if (! is.null(format)) nobs <- sprintf(format, nobs)
  names(nobs) <- eths
  nobs
}


# avoid warnings about zero weights
svyglm_quiet <- function (...) suppressWarnings(svyglm(...))


# for a confidence interval
significant <- function (x) {
  stopifnot(is.numeric(x), length(x) == 2)
  all(x < 0) || all(x > 0)
}


insignificant <- Negate(significant)


# rand HRS longit data. VERY BIG
# Done just once:
# rand_orig <- haven::read_dta("data/randhrs/randhrs1992_2020v1.dta")
# saveRDS(rand_orig, file = "data/randhrs/rand-orig.rds", compress = FALSE)
rand_orig <- readRDS("data/randhrs/rand-orig.rds")

# ragender: 1 male, 2 female
rand_orig <- filter(rand_orig, 
                    (rabyear <= 1965 & ragender == 1) |
                    (rabyear <= 1970 & ragender == 2))

# african ancestry
pgen4a <- haven::read_dta("data/PGENSCORE4r3/pgenscore4a_r.dta")
# european ancestry
pgen4e <- haven::read_dta("data/PGENSCORE4r3/pgenscore4e_r.dta")

# original HRS tracker file
trk_orig <- haven::read_dta("data/trk2020v3/trk2020tr_r.dta")
trk_weights <- trk_orig |> select(HHID, PN, matches("BIOWGTR"))

# rand family respondents file
# Done just once:
# rand_fam <- haven::read_dta(
#   "data/randhrsfam1992_2018v2_STATA/randhrsfamr1992_2018v2.dta")
# saveRDS(rand_fam, "data/randhrsfam1992_2018v2_STATA/rand_fam.rds")
rand_fam <- readRDS("data/randhrsfam1992_2018v2_STATA/rand_fam.rds")
# only selected columns to avoid creating suffixes when we join with
# rand.
# Age of oldest kid; grandchildren; num siblings who died
rand_fam <- rand_fam |> select(hhid, pn, h10ageokid, h10gkid, r10sbdied)


# 2010 (and others) record "age started smoking"
# rand_2010 <- haven::read_dta("data/hd10f6a_STATA/hd10f6a.dta")
# saveRDS(rand_2010, "data/hd10f6a_STATA/rand_2010.rds")
rand_2010 <- readRDS("data/hd10f6a_STATA/rand_2010.rds")
rand_2010 <- rand_2010 |> 
  select(hhid, pn, mc120, matches("mlb041")) |> 
  mutate(
    age_smoked = ifelse(mc120 %in% c(95, 98, 99), NA_real_, mc120)
  )
rand_2010$anxiety <- rand_2010 |> 
  select(matches("mlb041")) |> 
  rowMeans(na.rm = TRUE)
rand_2010$anx_na <- rand_2010 |> 
  select(matches("mlb041")) |> 
  is.na() |> 
  rowSums()
# matches the documentation at 
# https://hrs.isr.umich.edu/sites/default/files/biblio/HRS2006LBQscale.pdf :
rand_2010$anxiety[rand_2010$anx_na > 2] <- NA_real_

# 2016 survey had a module with 18 questions diagnosing adult ADHD
# rand_2016 <- haven::read_dta("data/h16f2c_STATA/h16f2c.dta")
# saveRDS(rand_2016, "data/h16f2c_STATA/rand_2016.rds")
rand_2016 <- readRDS("data/h16f2c_STATA/rand_2016.rds")
rand_2016 <- rand_2016 |> 
  select(hhid, pn, pv001:pv018) |> 
  mutate(
    across(matches("pv\\d\\d\\d"), \(x) ifelse(x %in% 8:9, NA, x)),
    across(matches("pv\\d\\d\\d"), \(x) x == 1) # 1 is "yes', 5 is "no"
  )
rand_2016$adhd_score <- rand_2016 |> 
  select(pv001:pv018) |> 
  rowSums(na.rm = TRUE)
rand_2016$adhd_nas <- rand_2016 |> 
  select(pv001:pv018) |> 
  is.na() |> 
  rowSums(na.rm = TRUE)
rand_2016$adhd_score <- rand_2016$adhd_score/(18 - rand_2016$adhd_nas)

pgens <- list(white = pgen4e, black = pgen4a)

pcs <- c(paste0("PC1_5", LETTERS[1:5]), paste0("PC6_10", LETTERS[1:5]))

rands <- list()

for (eth in eths) {
  pgen <- pgens[[eth]]
  names(pgen) <- shorten(names(pgen))
  rands[[eth]] <- inner_join(rand_orig, pgen,
                     join_by(hhid, pn),
                     unmatched = "drop",
                     relationship = "one-to-one")
}

rand <- list_rbind(rands, names_to = "ethnicity")

old_pgs <- c("EDU2", "EDU3", "HEIGHT", "BMI",
           "AD", "AD2", "GENCOG", "EVRSMK", "LONG", "CPD_TAG10",
           "ADHD_PGC10", "MDD")
pgs <- pgen4e |>
    rename_with(shorten) |> 
    # weird that I have to operate on whole df to use select semantics
    select(-hhid, -pn, -version,
           -matches("^PC\\d"),
           -matches("^NEB"), # number ever born
           # outdated, or EDU3 without 23andMe:
           -any_of(old_pgs)
           ) |>
    names()


# weighting
rand <- left_join(rand, trk_weights, by = join_by(hhid == HHID, pn == PN))
rand$weight <- ifelse(is.na(rand$MBIOWGTR), rand$NBIOWGTR, rand$MBIOWGTR)
# compensate for fecund parents more likely to have child in survey.
# we use living sibs rather than including dead sibs too here. I think that's
# the correct approach:
rand$parent_weight <- rand$weight / (rand$r10livsib + 1)

rand <- rand |> left_join(rand_fam, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

rand <- rand |> left_join(rand_2016, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

rand <- rand |> left_join(rand_2010, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

rand <- rand |>
  mutate(.by = rabyear, # calculate this pooling ethnicity
    mean_raevbrn = mean(raevbrn, na.rm = TRUE),
    rlrs = raevbrn/mean_raevbrn
  ) |>
  mutate(.by = ethnicity, # calculate these stats within-ethnicity
    income_resid = calc_income(rand, ethnicity[1]),
    income_resid = income_resid - min(income_resid, na.rm = TRUE) + 1,
    income_med = chop_equally(income_resid, 2, labels = c("Low", "High")),
    # as.numeric avoids haven.labelled issues:
    raedyrs = as.numeric(raedyrs),
    r10hearte = as.numeric(r10hearte),
    r10diabe = as.numeric(r10diabe),
    edu = chop(as.numeric(raedyrs), 13, lbl_discrete(symbol = "-")),
    # wave 10 is 2010
    # table(rands$white$r10mstat)
     # 1                 1.married
     # 2   2.married,spouse absent
     # 3               3.partnered
     # 4               4.separated
     # 5                5.divorced
     # 6      6.separated/divorced
     # 7                 7.widowed
     # 8           8.never married
    married = factor(r10mstat == 1, 
                     levels = c(FALSE, TRUE),
                     labels = c("Other", "Married")),
    r10sibs = r10livsib + 1, # n. sibs including oneself!
    agefbn = r10agey_e - h10ageokid,
    agefbn = ifelse(agefbn < 12, NA_real_, agefbn),
  ) |> 
  mutate(.by = c(ethnicity, ragender),
    agefb = chop_equally(agefbn, 2, labels = c("Low", "High"))
  )

rand$neurot <- rand |> 
  select(matches("r\\d+lbneur")) |> 
  rowMeans(na.rm = TRUE)

# two of four Alzheimer's variants with awkward names:
pgs <- str_replace(pgs, "^01", "ALZ_01")
names(rand) <- str_replace(names(rand), "^01", "ALZ_01")


rand <- rand |> 
  select(ethnicity, all_of(pgs), all_of(old_pgs), 
         all_of(pcs), weight, raevbrn, rlrs,
         raedyrs, r10sibs, edu, income_med, married, agefb, agefbn,
         rabyear, raehsamp, raestrat, parent_weight, ragender,
         adhd_score, neurot, r10diabe, r10hearte, r10cesd, age_smoked,
         anxiety, r10cogtot)

r_parents <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ parent_weight, 
		nest = TRUE,
		data = rand |> drop_na(parent_weight) 
		)

rand <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ weight, 
		nest = TRUE,
		data = rand |> drop_na(weight) 
		)

n_white <- nrow(rand |> subset(ethnicity == "white"))
n_black <- nrow(rand |> subset(ethnicity == "black"))

# clean up cache so it doesn't get too big
rm(rand_orig, trk_orig, rands, rand_fam, rand_2010, rand_2016)
```

@hugh2022human explain patterns of natural selection on polygenic scores in the UK, using an economic theory of fertility derived from @becker1976child. The theory has two components.

1.  There is a trade-off between time spent working and raising children. This leads people with more human capital and higher expected wages to have fewer children. Evidence for this is that polygenic scores which correlate positively with human capital correlate negatively with number of children, i.e. they are being selected against; conversely, scores which correlate positively with human capital are being selected for.
2.  The trade-off is sharper for low-income people, people with low human capital, and single parents. As a result, natural selection is stronger among these groups. Evidence for this is that scores' regression coefficients on number of children are larger among people with lower income or less education, and single parents.

Here, I make an independent test of the theory in the US population, using the Health and Retirement Survey [@hrsrandfam2023; @hrsrand2023]. The HRS is more representative of the population than UK Biobank, which addresses one potential weakness of the previous paper. The HRS also provides precalculated polygenic scores [@hrspgs2020] for both black and (non-hispanic) white participants, so I can check whether the theory predicts patterns of natural selection in both these ethnicities.

# Data

The HRS sample focuses on cohorts born between 1920 and 1960, but contains some younger and older participants. I include only male participants born before 1965 and female participants born before 1970, which guarantees that most will have completed their fertility by 2010. The resulting sample contains `r n_white` genotyped white participants and `r n_black` genotyped black participants.

Genotyping took place in 2006, 2008 and subsequent years. I discard obsolete PGS for which there is a newer, more accurate score targeting the same phenotype. I also discard PGS for number of children ever born (but keep scores for age at first birth). This leaves a total of `r length(pgs)` scores. PGS are rescaled to zero mean and unit variance within each ethnic group, so coefficient sizes are not directly comparable between ethnic groups, but are measured in standard deviations of the within-ethnic-group score. In all regressions using PGS, I control for ten within-ethnicity principal components of the DNA array data.

The key dependent variable is relative lifetime reproductive success (RLRS): number of children ever born, divided by mean number of children of people born in the same year. RLRS is calculated pooling ethnicities, i.e. treating them as members of the same biological population.

The HRS contains weights which match survey respondents to the US population. I use weights for the biomarker subsample (\*BIOWGTR in the HRS tracker file). Since half the sample enters the extended interview including biomarker data in each biannual survey, I weight individuals by either their 2010 weight or their 2012 weight. This maximizes the available sample of both black and white respondents, and should approximately match the US population of the sample cohorts between 2010 and 2012. Statistical tests are adjusted for clustering and stratification using the R "survey" package [@lumleysurvey2023].

# Results

```{r}
#| label: stat-regressions

# cache seems to cause trouble even with cache-lazy: FALSE 

tidy_pgs <- mod_pgs <- list()
tidy_pgs_ed <- mod_pgs_edyrs <- list()
tidy_pgs_sibs <- mod_pgs_sibs <- list()
tidy_pgs_x_ed <- mod_pgs_x_ed <- list()
tidy_pgs_x_inc <- mod_pgs_x_inc <- list()
tidy_pgs_x_mar <- mod_pgs_x_mar <- list()
tidy_pgs_x_agefb <- mod_pgs_x_agefb <- list()

coefs_fert_edu <- cors_fert_edu <- tidy_pgs_joined <- list()
cors_sibs_edu <- list()
tidy_fert_edu_phen <- list()

for (eth in eths) {
  r_eth <- rand |> subset(ethnicity == eth)
  r_parents_eth <- r_parents |> subset(ethnicity == eth)
  
  form_pgs <- map(pgs, \(x) reformulate(c(x, pcs), response = "rlrs"))
  mod_pgs[[eth]] <- map(form_pgs, 
                               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs[[eth]] <- mod_pgs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |> 
    list_rbind() |>
    filter(term %in% pgs)
  
  form_pgs_edyrs <- map(pgs, \(x) reformulate(c(x, pcs),
                                              response = "raedyrs"))
  mod_pgs_edyrs[[eth]] <- map(form_pgs_edyrs, 
                                     \(x) svyglm_quiet(x, r_eth))
  names(mod_pgs_edyrs[[eth]]) <- pgs
  
  tidy_pgs_ed[[eth]] <- mod_pgs_edyrs[[eth]] |>  
    map(broom::tidy) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  tidy_pgs_joined[[eth]] <- inner_join(tidy_pgs[[eth]], tidy_pgs_ed[[eth]],
                                by = join_by(term),
                                unmatched = "error",
                                suffix = c(".fert", ".edyrs"),
                                relationship = "one-to-one")
  cors_fert_edu[[eth]] <- cor(tidy_pgs_joined[[eth]]$estimate.edyrs, 
                     tidy_pgs_joined[[eth]]$estimate.fert)
  coefs_fert_edu[[eth]] <- lm(estimate.fert ~ estimate.edyrs,
                              data = tidy_pgs_joined[[eth]]) |> 
                           coef() |> 
                           pluck("estimate.edyrs")
  
  form_pgs_sibs <- map(pgs, 
                       \(x) reformulate(c(x, pcs), response = "r10sibs"))
  mod_pgs_sibs[[eth]] <- map(form_pgs_sibs,
                                    \(x) svyglm_quiet(x, r_parents_eth))
  
  tidy_pgs_sibs[[eth]] <- mod_pgs_sibs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  cors_sibs_edu[[eth]] <- cor(tidy_pgs_sibs[[eth]]$estimate, 
                     tidy_pgs_ed[[eth]]$estimate)
  

  tidy_fert_edu_phen[[eth]] <- 
    svyglm_quiet(rlrs ~ raedyrs, r_eth) |> 
    broom::tidy(conf.int = TRUE) |> 
    filter(term == "raedyrs")
}

# we only look at interactions among whites, the rest is pointless
for (eth in "white") {
  r_eth <- rand |> subset(ethnicity == eth)
  
  # the colon interaction estimates the effect separately within each group
  form_pgs_x_ed <- paste0(pgs, ":edu") |>
    map(\(x) reformulate(c(x, "edu", pcs), response = "rlrs"))
  mod_pgs_x_ed[[eth]]  <-
    map(form_pgs_x_ed, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_ed[[eth]] <-
    map(mod_pgs_x_ed[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_ed[[eth]]) <- pgs
  tidy_pgs_x_ed[[eth]] <-
    list_rbind(tidy_pgs_x_ed[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "edu13-17", pcs)) |>
    mutate(edu = str_remove(term, ".*:"))
  
  form_pgs_x_inc <- paste0(pgs, ":income_med") |>
    map(\(x) reformulate(c(x, "income_med", pcs), response = "rlrs"))
  mod_pgs_x_inc[[eth]]  <-
    map(form_pgs_x_inc, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_inc[[eth]] <-
    map(mod_pgs_x_inc[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_inc[[eth]]) <- pgs
  tidy_pgs_x_inc[[eth]] <-
    list_rbind(tidy_pgs_x_inc[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "income_medHigh", pcs)) |>
    mutate(income_med = str_remove(term, ".*:income_med"))
  
  form_pgs_x_mar <- paste0(pgs, ":married") |>
    map(\(x) reformulate(c(x, "married", pcs), response = "rlrs"))
  mod_pgs_x_mar[[eth]]  <-
    map(form_pgs_x_mar, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_mar[[eth]] <-
    map(mod_pgs_x_mar[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_mar[[eth]]) <- pgs
  tidy_pgs_x_mar[[eth]] <-
    list_rbind(tidy_pgs_x_mar[[eth]], names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "marriedMarried", pcs)) |>
    mutate(
      married = str_remove(term, ".*:married")
    ) 
  
  form_pgs_x_agefb <- paste0(pgs, ":agefb") |>
    map(\(x) reformulate(c(x, "agefb", pcs), response = "rlrs"))
  mod_pgs_x_agefb[[eth]]  <-
    map(form_pgs_x_agefb, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_agefb[[eth]] <-
    map(mod_pgs_x_agefb[[eth]], broom::tidy, conf.int = TRUE) |> 
    setNames(pgs) |> 
    list_rbind(names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "agefbHigh", pcs)) |>
    mutate(
      agefb = str_remove(term, ".*:agefb")
    ) 
}

tidy_pgs_eth <- list_rbind(tidy_pgs)
n_tests <- nrow(tidy_pgs_eth)
n_sig_bonf <- sum(tidy_pgs_eth$p.value < 0.05/n_tests)

```

```{r}
#| label: stat-bootstrap-eth-cor
#| cache: true
#| cache-lazy: false
#| eval: false

# I don't mention this below so turning it off for now
# TODO: should I mention it? It's a low correlation.

n_reps_eth_diff <- 99
rand_boot <- rand |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_eth_diff)


calc_eth_cor <- function (weights, data) {
  coef_pgs_white <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "white")) |> 
        map2_dbl(pgs, \(x, y) coef(x)[[y]])
  coef_pgs_black <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "black")) |> 
        map2_dbl(pgs, \(x, y) coef(x)[[y]])
  
  c(cor = cor(coef_pgs_black, coef_pgs_white))
}


cor_eths <- cor(tidy_pgs$white$estimate, tidy_pgs$black$estimate)
cor_eths_boot <- withReplicates(rand_boot, theta = calc_eth_cor)
ci_eths <- confint(cor_eths_boot)[1,]
```

I estimated coefficients of PGS on RLRS among black and white respondents separately. These are not meant to identify causal effects; recall that natural selection involves correlation, not necessarily causation, between selected characteristics and fertility. Appendix @fig-rlrs shows coefficients for white respondents only; power is too low for individual PGS estimates to be informative in the black sample. Standard errors are large because of the relatively low sample sizes, and only `r n_sig_bonf` score is significant at Bonferroni-corrected p \< 0.05/`r n_tests`. But I am most concerned with looking at patterns across scores rather than judging the significance of individual scores.

```{r}
#| label: stat-bootstraps
#| cache: true
#| cache-lazy: false
#| cache-comments: false


# Not sure this actually does anything :-)
old_opts <- options(survey.multicore = TRUE) 

# The large n_reps is to get an accurate upper tail on the black sample, 
# since it is close to 0:
n_reps <- 599

calc_cors_edu <- function (weights, data, var) {
  coef_pgs_fert <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = var)) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  coef_pgs_edu <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "raedyrs")) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  c(
    cor = cor(coef_pgs_edu, coef_pgs_fert),
    coef = coef(lm(coef_pgs_fert ~ coef_pgs_edu))["coef_pgs_edu"]
  )
}
  

cors_fert_edu <- cors_sibs_edu <- list()
for (eth in eths) {
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  r_parents_boot <- r_parents |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  
  cors_fert_edu[[eth]] <- 
    withReplicates(rand_boot, theta = calc_cors_edu, var = "rlrs")
  cors_sibs_edu[[eth]] <- 
    withReplicates(r_parents_boot, theta = calc_cors_edu, var = "r10sibs")
}

options(old_opts)
```

```{r}
#| label: stat-bootstrap-eth-diff
#| eval: false

# this was an attempt to see if black coefs were larger in abs size than
# white coefs. Results were always absolutely insignificant (and conf
# intervals too wide to be informative).

n_reps_eth_diff <- 99
rand_boot <- rand |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_eth_diff)


calc_eth_diff <- function (weights, data) {
  coef_pgs_white <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "white")) |> 
        map_dbl(\(x) coef(x)[[2]])
  coef_pgs_black <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "black")) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  # this is positive if white was "bigger" than black taking the white sign 
  # as the correct sign. Negative if b was "bigger"  than w.
  diff_coefs <- (coef_pgs_white - coef_pgs_black)*sign(coef_pgs_white)
  names(diff_coefs) <- pgs
  c(diff = mean(diff_coefs))
}

diff_eths <- withReplicates(rand_boot, theta = calc_eth_diff)
```

```{r}
#| label: stat-post-bootstraps

# separate so we don't interfere with the bootstrap cache

ci_boot_fert <- map(cors_fert_edu, \(x) confint(x)[1,])
ci_boot_sibs <- map(cors_sibs_edu, \(x) confint(x)[1,])

ci_boot_fert_lm <- map(cors_fert_edu, \(x) confint(x)[2,])
ci_boot_sibs_lm <- map(cors_sibs_edu, \(x) confint(x)[2,])

if (insignificant(ci_boot_fert$white)) warning("ci_boot_fert$white insignificant")
if (! insignificant(ci_boot_fert$black)) warning("ci_boot_fert$black significant")
if (significant(ci_boot_sibs$white)) warning("ci_boot_sibs$white significant")
if (significant(ci_boot_sibs$black)) warning("ci_boot_sibs$black significant")
```

@fig-rlrs-edu plots each PGS's partial correlation with RLRS against its partial correlation with educational attainment. The relationship is negative among whites (correlation `r cors_fert_edu$white[1]`, bootstrap 95% C.I. `r ci_boot_fert$white[1]` to `r ci_boot_fert$white[2]`) and negative but insignificant among blacks (correlation `r cors_fert_edu$black[1]`, bootstrap 95% C.I. `r ci_boot_fert$black[1]` to `r ci_boot_fert$black[2]`). Survey bootstraps [@canty1999resampling] are used so as to make inferences from the sample of respondents.

```{r}
#| label: fig-rlrs-edu
#| fig-cap: |
#|   Scatterplot of PGS regression coefficients on RLRS against 
#|   coefficients on years of education. Each dot is one polygenic score.
#|   Controls include 10 principal components of genetic array
#|   data. Dashed lines are fitted from linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <- ggplot(tidy_pgs_joined[[eth]], aes(estimate.edyrs, estimate.fert)) +
          geom_hline(yintercept = 0, color = "grey80") +
          geom_vline(xintercept = 0, color = "grey80") +
          geom_point() +
          geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                      linetype = "dashed", colour = "red", linewidth = 0.5) +
          scale_y_continuous(breaks = seq(-0.35, 0.15, 0.05),
                             labels = scales::label_number(0.01)) +
          coord_cartesian(xlim = c(-.3, .75)) +
          theme_light() + 
          theme(panel.grid = element_blank()) +
          labs(
            title = titles[eth],
            x = "Coefficient on years of education",
            y = "Coefficient on RLRS"
          )
  print(ggp)
}

# TODO: 3 scores are outliers among african-americans, with negative effects
# on fertility and education - kidney disease, including the trans-ethnic
# score, and PTSD estimated among european ancestry. Why?
```

```{r}
#| label: stat-siblings

tmp <- 
  tidy_pgs_sibs$black |> 
  inner_join(tidy_pgs_ed$black, 
             by = join_by(term), 
             suffix = c(".sibs", ".edyrs")) |> 
  filter(term != "GWAD2NA", term != "GWAD2WA")

cor_no_outliers <- cor(tmp$estimate.sibs, tmp$estimate.edyrs)
if (! cor_no_outliers < 0) stop("Correlation without outliers IS NOT neg.")
```

```{r}
#| label: stat-bootstrap-gen-cor
#| cache: true

n_reps_gen_cor <- 199

f_resp <- map(pgs, \(x) reformulate(c(x, pcs), response = "raevbrn"))
f_sibs <- map(pgs, \(x) reformulate(c(x, pcs), response = "r10sibs"))
  
estimate_gen_cor <- function (w, data) {
  data$w <- w # avoid w getting lost by map and lm
  m_resp <- map(f_resp, \(x) lm(x, data, weights = w))
  m_sibs <- map(f_sibs, \(x) lm(x, data, weights = w/r10sibs))
  
  coef_resp <- map2_dbl(m_resp, pgs, \(x, y) coef(x)[[y]])
  coef_sibs <- map2_dbl(m_sibs, pgs, \(x, y) coef(x)[[y]])
  c(gen_cor = cor(coef_resp, coef_sibs))
}

rand_boot <- rand |> 
    subset(ethnicity == "white") |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_gen_cor)

gen_cor <- withReplicates(rand_boot, theta = estimate_gen_cor)
ci_gen_cor <- confint(gen_cor)
```

I can also examine natural selection in the previous generation, by regressing PGS on respondents' number of living siblings in 2010. (Data for dead siblings has too many missing values to use.) I reweight respondents by the reciprocal of their number of siblings, to account for parents of many siblings being more likely to be a parent of a respondent. Parents of no siblings cannot be included, so coefficient sizes are not comparable across the generations. Appendix @fig-siblings plots coefficients on number of siblings versus coefficients on years of education. Correlations are insignificant for both ethnic groups, with large standard errors (whites: correlation `r cors_sibs_edu$white[1]`, bootstrapped 95% C.I. `r ci_boot_sibs$white[1]` to `r ci_boot_sibs$white[2]`; blacks: correlation `r cors_sibs_edu$black[1]`, bootstrapped 95% C.I. `r ci_boot_sibs$black[1]` to `r ci_boot_sibs$black[2]`). However, there is a positive and significant correlation across generations, i.e. between PGS coefficients on number of siblings and number of children, of `r gen_cor`, bootstrapped 95% C.I. `r ci_gen_cor[1,1]` to `r ci_gen_cor[1,2]`.

I next test part 2 of the theory by interacting PGS with measures of education, income, marital status, and age at first birth. Education is years of education, split at 12 years. Income is respondent's mean wage income over all surveys, residualized on a full set of birth year dummies, and median-split. From here on I only use the white subsample: there are too few black respondents to be informative.

```{r}
#| label: stat-x-bootstrap-cors
#| cache: true
#| cache-lazy: false
#| eval: false

old_opts <- options(survey.multicore = TRUE) 

# all confindence intervals were too wide to be informative
n_reps_x <- 99

calc_diff_cor_ed <- function (w, data, term) {
  groups <- switch(term,
                edu = c("0-12", "13-17"),
                income_med = c("Low", "High"),
                married = c("Other", "Married"),
                agefb = c("Low", "High"))
  groups <- paste0(":", term, groups) # colon for the cross term
  low_group <- groups[1]
  high_group <- groups[2]
  
  forms <- paste0(pgs, ":", term) |>
    map(\(x) reformulate(c(x, term, pcs), response = "rlrs"))
  mods <- map(forms, \(x) lm(x, data, weights = w))
  cfs <- map(mods, coef)
  cfs_low <- map_dbl(cfs, \(x) x[str_detect(names(x), low_group)])
  cfs_high <- map_dbl(cfs, \(x) x[str_detect(names(x), high_group)])
  
  forms_ed <- paste0(pgs, ":", term)  |> 
    map(\(x) reformulate(c(x, term, pcs), response = "raedyrs"))
  mods_ed <- forms_ed |> map(\(x) lm(x, data, weights = w))
  cfs_ed <- map(mods_ed, coef)
  cfs_ed_low <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), low_group)])
  cfs_ed_high <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), high_group)])
  
  cor_ed_low <- cor(cfs_low, cfs_ed_low)
  cor_ed_high <- cor(cfs_high, cfs_ed_high)
  
  c(low = cor_ed_low, high = cor_ed_high, diff = cor_ed_low - cor_ed_high)
}

diff_cor_ed <- ci <- est <- tbl <- list()

terms <- c("edu", "income_med", "married", "agefb")
for (eth in eths) {
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_x)
  
  for (term in terms) {
    diff_cor_ed[[eth]][[term]] <- 
      withReplicates(rand_boot, theta = calc_diff_cor_ed, term = term)  
    ci[[eth]][[term]] <- confint(diff_cor_ed[[eth]][[term]])
    est[[eth]][[term]] <- as.numeric(diff_cor_ed[[eth]][[term]])
  }
}

options(old_opts)


```

```{r}
#| label: stat-x-bootstrap-effect-size
#| cache: true
#| cache-lazy: false
#| cache-comments: false

old_opts <- options(survey.multicore = TRUE) 

n_reps_x_es <- 99

calc_diff_effect_size <- function (w, data, term) {
  groups <- switch(term,
                edu = c("0-12", "13-17"),
                income_med = c("Low", "High"),
                married = c("Other", "Married"),
                agefb = c("Low", "High"))
  groups <- paste0(":", term, groups) # colon for the cross term
  low_group <- groups[1]
  high_group <- groups[2]
  
  forms <- paste0(pgs, ":", term) |>
    map(\(x) reformulate(c(x, term, pcs), response = "rlrs"))
  mods <- map(forms, \(x) lm(x, data, weights = w))
  cfs <- map(mods, coef)
  cfs_low <- map_dbl(cfs, \(x) x[str_detect(names(x), low_group)])
  cfs_high <- map_dbl(cfs, \(x) x[str_detect(names(x), high_group)])
  
  abs_eff_low <- mean(abs(cfs_low))
  abs_eff_high <- mean(abs(cfs_high))
  diff_abs_eff <- abs_eff_low - abs_eff_high
  c(low = abs_eff_low, high = abs_eff_high, diff = diff_abs_eff)
}


diff_effect_size <- ci <- est <- tbl <- list()

terms <- c("edu", "income_med", "married", "agefb")

rand_boot <- rand |> 
  subset(ethnicity == "white") |> 
  as.svrepdesign(type = "bootstrap", replicates = n_reps_x_es)

for (term in terms) {
  diff_effect_size[[term]] <- 
    withReplicates(rand_boot, theta = calc_diff_effect_size, term = term)  
  ci[[term]] <- confint(diff_effect_size[[term]])
  est[[term]] <- as.numeric(diff_effect_size[[term]])
  tbl[[term]] <- sprintf("%.3f (%.3f to %.3f)", est[[term]], 
                         ci[[term]][, 1], ci[[term]][, 2])
}

options(old_opts)

```

```{r}
#| label: stat-agefb-bootstrap

n_reps_agefb <- 9
calc_cor_agefb <- function (w, data) {
  forms <- pgs |> map(\(x) reformulate(c(x, pcs), response = "raevbrn"))
  mods_low <- map(forms, \(x) lm(x, data, subset = agefb == "Low",
                                 weights = w))
  mods_high <- map(forms, \(x) lm(x, data, subset = agefb == "High",
                                  weights = w))
  coefs_low <- map2_dbl(mods_low, pgs, \(x, y) coef(x)[[y]])
  coefs_high <- map2_dbl(mods_high, pgs, \(x, y) coef(x)[[y]])
  
  c(
    cor = cor(coefs_low, coefs_high), 
    discordant = sum(sign(coefs_low) != sign(coefs_high)) # discordant pairs
  )
}

rand_boot <- rand |> 
  subset(ethnicity == "white") |> 
  as.svrepdesign(type = "bootstrap", replicates = n_reps_agefb)

cor_agefb <- withReplicates(rand_boot, theta = calc_cor_agefb)

stopifnot(insignificant(confint(cor_agefb)[1,]))
ci_discordant <- confint(cor_agefb)[2,]
# significantly different from 1/2?
stopifnot(ci_discordant[1] <= length(pgs)/2 && 
            ci_discordant[2] >= length(pgs)/2)

```

```{r}
#| label: stat-post-x-bootstrap

stopifnot(insignificant(ci$edu[3,]))
stopifnot(significant(ci$income_med[3,]))
stopifnot(significant(ci$married[3,]))
stopifnot(insignificant(ci$agefb[3,]))

tidy_agefb_wide <- tidy_pgs_x_agefb$white |> 
  pivot_wider(id_cols = pgs, names_from = agefb, values_from = estimate)

cor_agefb <- cor(tidy_agefb_wide$Low, tidy_agefb_wide$High)
n_discordant <- sum(sign(tidy_agefb_wide$Low) != sign(tidy_agefb_wide$High))
```

Appendix @fig-x-edu shows essentially no difference in the distribution of absolute coefficient sizes between respondents with more and less education. Appendix @fig-x-inc, on the other hand, shows that coefficients appear larger among lower-income respondents. Appendix @fig-x-mar shows absolute coefficients for respondents who were married in 2010 against all other statuses. Coefficients appear larger for unmarried respondents.

Appendix @fig-x-agefb splits respondents by age at first birth (median within each gender). Note that the N is lower here due to missing values. There are no large differences between younger and older parents. As in the UK Biobank sample, correlations of PGS coefficients between younger and older parents are negative (`r cor_agefb`), and for `r n_discordant` out of `r length(pgs)` PGS, coefficients have opposite signs. However, in bootstraps, these statistics are not significantly different from 0 and `r length(pgs)/2` respectively. Also, in the UK Biobank sample, PGS coefficients on fertility controlling for age at first birth were negatively correlated with uncontrolled coefficient; here, that isn't true, with coefficients remaining positively correlated.

```{r}
#| label: stat-control-agefb
#| eval: false

# cselection effects ontrolling for age at first birth
# 
form_pgs_control_agefb <- map(pgs, \(x) reformulate(c(x, "agefbn", pcs), 
                                                    response = "rlrs"))
mod_pgs_control_agefb <- map(form_pgs_control_agefb,
                             \(x) svyglm_quiet(x, rand, subset = 
                                                 ethnicity == "white"))
tidy_pgs_control_agefb <- map(mod_pgs_control_agefb, broom::tidy) |> 
                          list_rbind() |> 
                          filter(term %in% pgs)

cor(tidy_pgs$white$estimate, tidy_pgs_control_agefb$estimate)

```

@tbl-x-bootstraps shows means and 95% confidence intervals for mean absolute coefficient sizes in each pair of groups, and the difference between them, using bootstraps. Differences for income and marriage are significant.

|               | Low group             | High group            | Difference            |
|------------------|------------------|------------------|------------------|
| Education     | `r tbl$edu[1]`        | `r tbl$edu[2]`        | `r tbl$edu[3]`        |
| Income        | `r tbl$income_med[1]` | `r tbl$income_med[2]` | `r tbl$income_med[3]` |
| Marriage      | `r tbl$married[1]`    | `r tbl$married[2]`    | `r tbl$married[3]`    |
| Age 1st birth | `r tbl$agefb[1]`      | `r tbl$agefb[2]`      | `r tbl$agefb[3]`      |

: Bootstrap estimates and 95% confidence intervals for mean absolute coefficients of PGS on RLRS in "low" and "high" groups among white respondents. Groups are: 0-12 years education vs. 13-17 years; below vs. above median income; all others vs. married; below vs. above median age at first birth. `r n_reps_x_es` bootstraps. {#tbl-x-bootstraps tbl-colwidths="\[16,28,28,28\]"}

The economic theory of fertility also implies that correlations between education and RLRS should be more negative for lower-income/education people, single parents and people who have children earlier.[^1] This in turn implies that correlations between PGS coefficients on education and on RLRS should be more negative among these groups. I tested this with bootstraps, but confidence intervals were always too wide to be informative.

[^1]: See @hugh2022human equation (6) and following.

```{r}
#| label: stat-pgs-over-time
#| eval: false

# Plot changes in a couple of variables by decade
# Below: "Changes in PGS over time are small for both groups..."
 
rand$variables$birth_decade <- chop_width(rand$variables$rabyear, 10, 1920)
decades_adhd <- svyby(~ADHD_PGC17, ~ birth_decade + ethnicity, rand, 
                      FUN = svymean) 
decades_ea3 <- svyby(~EA3, ~ birth_decade + ethnicity, rand, 
                     FUN = svymean) 

# example plot
ggplot(decades_ea3, aes(birth_decade, EA3, color = ethnicity, 
                        group = ethnicity)) + 
  geom_line() +
  geom_pointrange(aes(ymax = EA3 + 1.96 * se, ymin = EA3 - 1.96 * se))

```

Why does the US data show fewer differences by socio-economic status (SES) than the UK? One possibility is that SES maps on to race in the US, so that ethnic differences here capture some of the variation seen in the UK. The regression coefficient of phenotypic educational attainment on fertility is more negative among black than white respondents (blacks: `r tidy_fert_edu_phen$black$estimate`, 95% C.I. `r tidy_fert_edu_phen$black$conf.low` to `r tidy_fert_edu_phen$black$conf.high`; whites: `r tidy_fert_edu_phen$white$estimate`, 95% C.I. `r tidy_fert_edu_phen$white$conf.low` to `r tidy_fert_edu_phen$white$conf.high`; cf. @goldscheider1969minority, @johnson1979minority, @yang2003big). And the slope of PGS education coefficients on fertility coefficients is larger among black respondents, though imprecisely estimated (see @fig-rlrs-edu). But comparisons of PGS selection coefficients between the ethnic groups are hard because of the smaller sample size and differences in the scores' predictive power, so this hypothesis can only be speculative. Looking within the sample, changes in PGS by birth year are small for both groups, and are probably mostly driven by selective mortality.

Lastly, we would like to know natural selection's effect sizes. The bivariate correlations of PGS with RLRS gives the change in one generation in the PGS due to natural selection, measured in standard deviations. Polygenic scores contain error, so estimated correlations are biased towards zero compared to the correlation of the true PGS. They can be scaled up by

$$
\hat{\beta}_{TRUE} = \hat{\beta}_{PGS}\sqrt{\frac{h^2}{R^2_{PGS}}
}$$

where $h^2$ is the heritability of the PGS target phenotype and $R^2_{PGS}$ is the $R^2$ of the measured PGS on the target phenotype [@becker2021resource]. I make this calculation using heritabilities from twin studies, and SNP- or chip-heritabilities (the total variance explained by SNPs recorded on array chips).[^2]

[^2]: Heritability estimates are from @marenberg1994genetic and @nikpay2017partitioning for coronary heart disease); @willemsen2015concordance and @mahajan2018fine for Type II diabetes; @evans2021genetic for age of smoking initiation; and @abdellaoui2021dissecting for everything else. I used low-end heritability estimates for Type II diabetes (22%) and heart disease (40%).

@fig-true-effects reports estimates for phenotypes where selection effects were nominally significant and a measure of the phenotype was available in-sample and was significantly predicted by the PGS. As a rule of thumb, a 0.1 standard deviation change in a polygenic score over a generation might count as "serious": about 54% of the new generation will be below the parents' mean. Many upper confidence bounds meet that threshold, but lower bounds are often small or include zero. The confidence bounds capture uncertainty from sampling variation, but not other sources, including uncertainty about the true $h^2$ , limitations of the within-sample phenotypes, noise from correlated environments, and for twin-heritability, different relationships with fertility among variants not measured on the chip. Given all this, the estimates mostly show the limits of our knowledge, and should be treated as best guesses only.

The HRS contains multiple PGS for several phenotypes, typically with the $R^2$ increasing over time. Appendix @fig-check-correction runs a sanity check in which I predict the coefficient of later scores on fertility, using earlier scores and the above formula. Mostly, earlier PGS do a good job at predicting the effect of later PGS on fertility, with the later PGS's point estimate within the earlier PGS's 95% confidence interval.

```{r}
#| label: stat-boot-true-effects
#| cache: true

#' Calculate corrected PGS
#'
#' @param w Weights
#' @param data Data frame
#' @param pgs Name(s) of polygenic score(s) columns in  `data`.
#' @param phenotype Name of target phenotype in `data`
#' @param chip_h2 Chip-heritability
#' @param twin_h2 Twin-study heritability
#'
#' @return A vector of corrected estimates of effects on fertility, 
#'   named like `source.to.target` 
#'   where `source` is one of `pgs` and target is either a `pgs` or the
#'   chip-PGS or true PGS. If `pgs` has more than one element then
#'   the function will correct pgs using each other as a sanity check. If
#'   `source == target` then that is the original uncorrected score.
#' @noRd
#'
#' @examples
boot_correct <- function (w, data, pgs, phenotype, chip_h2, twin_h2) {
  
  fs_fert <- map(pgs, \(x) reformulate(c(x, pcs), response = "rlrs"))
  fs_phen <- map(pgs, \(x) reformulate(c(x, pcs), response = phenotype))

  ms_fert <- map(fs_fert, \(x) lm(x, data = data, weights = w))
  ms_phen <- map(fs_phen, \(x) lm(x, data = data, weights = w))
  bhat_fert <- map2_dbl(ms_fert, pgs, \(x, y) coef(x)[[y]])
  bhat_phen <- map2_dbl(ms_phen, pgs, \(x, y) coef(x)[[y]])

  r2_phen <- map_dbl(ms_phen, \(x) {
    an <- car::Anova(x)
    an$`Sum Sq`[1]/sum(an$`Sum Sq`)  # incremental R2 of first term
  })

  r2_phen <- c(r2_phen, chip_h2, twin_h2)
  # the correction factor
  # lower triangular part of this shows how much you multiply to get from
  # COLNAME to ROWNAME
  rhos <- outer(r2_phen, r2_phen, \(x, y) sqrt(x/y)) 
  rownames(rhos) <- colnames(rhos) <- c(pgs, "Chip", "Twin")

  # multiply first column by bhat_edu[1] to give predictions from the
  # first PGS to the next ones; etc.
  # The diagonals of b_edu are exactly equal to bhat_edu
  # arow,column gives the predicted value of b by ROWNAME for COLNAME
  b_phen <- apply(rhos, 1, \(x) x * c(bhat_phen, NA, NA))
  b_fert <- apply(rhos, 1, \(x) x * c(bhat_fert, NA, NA))

  # don't include the last two rows of NA predictions "from chip/twin h2"
  b_fert <- b_fert[seq_along(pgs), , drop = FALSE]

  res <- c(b_fert)
  # TODO: are the "backward estimates" wrong?
  # TODO: check against the python tool from the PGI repository paper
  res_names <- outer(rownames(b_fert), colnames(b_fert),
                      \(x, y) paste0(x, ".to.", y))
  names(res) <- c(res_names)
  
  res
}

n_reps_true <- 199
rand_boot <- rand |> as.svrepdesign(type = "bootstrap", 
                                    replicates = n_reps_true)

correct_scores <- tibble::tribble(
  ~pgs                         , ~phenotype  , ~chip_h2, ~twin_h2,
  c("ADHD_PGC10", "ADHD_PGC17"), "adhd_score", 0.21    , 0.75    ,
  c("EDU2", "EDU3", "EA3")     , "raedyrs"   , 0.10    , 0.43    ,  
  "AFBC"                       , "agefbn"    , 0.05    , 0.26    ,
  "NEUROT"                     , "neurot"    , 0.10    , 0.37    ,
  "CD"                         , "r10hearte" , 0.22    , 0.4     ,
  "T2D"                        , "r10diabe"  , 0.18    , 0.22    , 
  c("MDD", "MDD2")             , "r10cesd"   , 0.08    , 0.37    ,
#  "ANXCC"                      , "anxiety"   , 0.31    , 0.45    ,
  "AI"                         , "age_smoked", 0.05    , 0.50    ,
  c("GENCOG", "GCOG2")         , "r10cogtot" , 0.19    , 0.86
)

correct_scores <- drop_na(correct_scores)
# Sources for chip/twin h2; Abdel.
# general cognition used h2 for "adult IQ"
# Except:
# heart disease 0.4 to 0.6 from https://www.nejm.org/doi/full/10.1056/nejm199404143301503
# via https://www.jacc.org/doi/full/10.1016/j.jacc.2014.12.033
# T2D  0.22 to 0.73...
# https://www.cell.com/ajhg/pdf/S0002-9297(12)00031-6.pdf
# https://www.cambridge.org/core/services/aop-cambridge-core/content/view/94E0005D626FB0399AA8FDDAC82F970E/S1832427415000833a.pdf/div-class-title-the-concordance-and-heritability-of-type-2-diabetes-in-34-166-twin-pairs-from-international-twin-registers-the-discordant-twin-discotwin-consortium-div.pdf
# anxiety (nb not social anxiety!)
# https://ajp.psychiatryonline.org/doi/full/10.1176/ajp.156.2.246
# generalized anxiet disorder 42%:
# https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0134865
# age of smoking initiation, including chip heritability
# http://www.matthewckeller.com/publications/Evans_Addiction_2021.pdf
# CAD chip heritability
# https://academic.oup.com/cardiovascres/article/113/8/973/2965332?login=false
# type ii diabetes chip heritability
# https://www.nature.com/articles/s41588-018-0241-6
# 'current anxiety symptoms' chip heritability
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7237282/

corrected_effects <- list()
for (i in seq(nrow(correct_scores))) {
  source_pgs <- correct_scores$pgs[[i]]
  phenotype <- correct_scores$phenotype[[i]]
  chip_h2 <- correct_scores$chip_h2[[i]]
  twin_h2 <- correct_scores$twin_h2[[i]]
  
  results <- withReplicates(rand_boot, theta = boot_correct, 
                            pgs = source_pgs, phenotype = phenotype, 
                            chip_h2 = chip_h2, twin_h2 = twin_h2)
  corrected_effects[[phenotype]] <- results |>
    as.data.frame() |>
    tibble::rownames_to_column(var = "rn") |>
    cbind(confint(results)) |>
    tibble::remove_rownames() |>
    setNames(c("rn", "mean", "SE", "conf.low", "conf.high")) |> 
    mutate(
      phenotype = phenotype,
      source.pgs = str_remove(rn, ".to.*"),
      target.pgs = str_remove(rn, ".*.to."),
      rn = NULL,
      .before = 1
    )
}

corrected_effects <- list_rbind(corrected_effects)
```

```{r}
#| label: fig-true-effects
#| fig-cap: |
#|   Estimated coefficients of true polygenic scores on RLRS calculated
#|   using estimates of chip- and twin-heritability and the most recent
#|   polygenic score.

# TODO: maybe just use the polygenic score name not the phenotype?
# TODO: why are some result bounds negative? e.g. ADHD? Presumably
#. because can have negative effect on RLRS?
# TODO: check the original phenotypes from which h2 ests were derived...
#. - is CAD the same as coronary heart disease (r10hearte)?
# TODO: why is ANXCC not predicting anxiety?
corrected_effects |> 
  mutate(
    Phenotype = nice_names[source.pgs],
    Heritability = target.pgs
  ) |> 
  filter(Heritability %in% c("Chip", "Twin"), ! source.pgs %in% old_pgs) |> 
  ggplot(aes(y = Phenotype, x = mean, xmin = conf.low, xmax = conf.high,
             color = Heritability)) +
    geom_vline(xintercept = 0, color = "grey60") +
    geom_pointrange(aes(linetype = Heritability == "Twin"),
                    position = position_dodge(0.2)) +
    scale_linetype(guide = "none") +
    coord_cartesian(xlim = c(- 0.3, 0.3)) +
    labs(x = "Corrected coefficient on RLRS", y = "") +
    theme_minimal() 

```

# Discussion

The results here provide qualified support for the economic theory of fertility as an explanation for contemporary natural selection in humans. PGS which predict less education are being selected for, and PGS which predict more education are being selected against. PGS coefficients on RLRS also appear larger for low-income groups and unmarried respondents. But there is little evidence for larger coefficients among people with lower education, or younger parents. This may be due to the low sample size. But in the UK, the between-group differences were large [@hugh2022human]; differences that big would surely have been visible here. The smaller black sample makes most tests inconclusive for this population: I can only say that the data do not reject a negative association between PGS correlations with RLRS and with education. Lastly, true effect sizes are estimated and are typically between 0-0.2 standard deviations.

# Appendix

## Acknowledgements

The HRS (Health and Retirement Study) is sponsored by the National Institute on Aging (grant number NIA U01AG009740) and is conducted by the University of Michigan.

## Figures

```{r}
#| label: fig-cohorts
#| fig-cap: Distribution of birth years for the sample

rand$variables |> 
    mutate(
      Ethnicity = fct_relevel(titles[ethnicity], "White", "Black")
    ) |> 
    ggplot(aes(rabyear, fill = Ethnicity)) + 
      geom_bar(position = "identity") +
      labs(x = "Birth year", y = "Count") +
      scale_fill_manual(values = c(Black = "orange2", White = "steelblue4")) +
      theme_minimal() +
      theme(legend.title = element_blank())  

```

```{r}
#| label: fig-rlrs
#| fig-cap: |
#|  Coefficients of PGS on RLRS among white respondents, controlling for 10
#|  principal components of
#|  genomic array data. Lines are 95% confidence intervals.
#| fig-height: 6


tidy_pgs$white |>
  mutate(
    term = nice_names[term],
    term = fct_reorder(term, estimate)
  ) |>
  ggplot(aes(estimate, term)) +
    geom_vline(xintercept = 0) +
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high), size = 0.3,
                    color = "steelblue3") +
    theme_light() + 
    labs(
      x = "", y = "",
      title = "Coefficients of polygenic scores on RLRS"
    ) +
    theme(
      axis.text.y = element_text(size = 7),
      panel.grid.major.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      legend.position = "none"
    )
```

```{r}
#| label: fig-siblings
#| fig-cap: |
#|   Scatterplot of PGS coefficients on number of live siblings and years of
#|   education. Controls include 10 principal components of genetic array
#|   data. Dashed lines show linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <-  
    tidy_pgs_sibs[[eth]] |> 
    inner_join(tidy_pgs_ed[[eth]], 
               by = join_by(term), suffix = c(".sibs", ".edyrs")) |> 
    ggplot(aes(estimate.edyrs, estimate.sibs)) +
      geom_hline(yintercept = 0, color = "grey80") +
      geom_vline(xintercept = 0, color = "grey80") +
      geom_point() +
      geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                  linetype = "dashed", colour = "red", linewidth = 0.5) +
      coord_cartesian(xlim = c(-.3, .75)) +
      theme_light() + 
      theme(panel.grid = element_blank()) +
      labs(
          title = eth,
          x = "Coefficient on years of education",
          y = "Coefficient on number of siblings"
      )
  print(ggp)
}

```

```{r}
#| label: prog-x-plots

geom_x_boxplot <- geom_boxplot(color = "grey50", outlier.shape = NA)
geom_x_point <- geom_point(aes(shape = pgs=="EA3"), 
                           position = position_jitter(width = 0.03), 
                           alpha = 0.5) 

themes_x <- theme_minimal() +
      theme(
          legend.position = "none",
          panel.grid.major.x = element_blank()
      ) 
```

```{r}
#| label: fig-x-edu
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within the low/high
#|   education group. Boxes show quartiles. 

tidy_pgs_x_ed$white |> 
  mutate(
    Education = str_remove(edu, "edu")
  ) |> 
  ggplot(aes(Education, abs(estimate), color = Education)) +
    geom_x_boxplot + geom_x_point +
    labs(
      x = "Years of education",
      y = "Absolute coefficient",
      title = paste("PGS coefficients on RLRS by education", 
                    calc_n(mod_pgs_x_ed))
    ) +
    themes_x
```

```{r}
#| label: fig-x-inc
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within the below/above
#|   median income group. Boxes show quartiles.

tidy_pgs_x_inc$white |> 
  mutate(
    Income = fct_relevel(income_med, c("Low", "High"))
  ) |> 
  ggplot(aes(Income, abs(estimate), color = Income)) +
    geom_x_boxplot + geom_x_point +
    labs(
      x = "Income",
      y = "Absolute coefficient",
      title = paste("PGS coefficients on RLRS by income", 
                    calc_n(mod_pgs_x_inc))
    ) +
    themes_x
```

```{r}
#| label: fig-x-mar
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within married 
#|   and other respondents. Boxes show quartiles.

tidy_pgs_x_mar$white |> 
    mutate(
      married = fct_relevel(married, "Other", "Married")
    ) |> 
    ggplot(aes(married, abs(estimate), color = married)) +
      geom_x_boxplot + geom_x_point +
      labs(
          x = "Married",
          y = "Absolute coefficient",
          title = paste("PGS coefficients on RLRS by marital status", 
                        calc_n(mod_pgs_x_mar))
      ) +
      themes_x

```

```{r}
#| label: fig-x-agefb
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within below/above
#|   median age at first birth respondents. Boxes show quartiles.

tidy_pgs_x_agefb$white |> 
    mutate(
      agefb = fct_relevel(agefb, "Low", "High")
    ) |> 
    ggplot(aes(agefb, abs(estimate), color = agefb)) +
      geom_x_boxplot + geom_x_point + 
      labs(
          x = "Age at first birth",
          y = "Absolute coefficient",
          title = paste("PGS coefficients on RLRS by age at first birth", 
                        calc_n(mod_pgs_x_agefb))
      ) +
      themes_x

```

```{r}
#| label: fig-check-correction
#| fig-cap: |
#|   Estimated coefficients of series of PGS on fertility 
#|   using errors-in-variables correction. "Own" is the uncorrected estimate
#|   using the PGS itself. Other estimates are from earlier PGS targeting
#|   the same phenotype, corrected via the method in @becker2021resource.
#| fig-height: 6

corrected_effects |> 
  filter(length(unique(source.pgs)) > 1, .by = phenotype) |> 
  filter(! target.pgs %in% c("Chip", "Twin")) |> 
  filter(
    ! target.pgs %in% old_pgs
  ) |> 
  mutate(
    Phenotype = case_match(phenotype,
                           "adhd_score" ~ "ADHD",
                           "r10cesd" ~ "Depression",
                           "r10cogtot" ~ "Cognition",
                           "raedyrs" ~ "Educ. attainment"
                           ),
    Target = target.pgs,
    Source = ifelse(source.pgs == target.pgs, "Own", source.pgs),
  ) |> 
  ggplot(aes(y = Target, x = mean, xmin = conf.low, xmax = conf.high,
             color = Source)) +
    geom_vline(xintercept = 0, color = "grey60") +
    geom_pointrange(position = position_dodge(0.7)) +
    geom_text(aes(x = mean, label = Source), hjust = "center", 
              vjust = 1.5,
              position = position_dodge(0.7), size = 2.5) + 
    scale_color_manual(values = c("Own" = "red"), guide = "none") +
    facet_grid(rows = vars(Phenotype), scales = "free", space = "free") +
    labs(x = "Corrected coefficient on RLRS", y = "Target PGS") +
    coord_cartesian(xlim = c(-0.05, 0.05)) + 
    theme_minimal() 

```

\FloatBarrier

# Bibliography
