---
title: "Natural selection in the Health and Retirement Study"
author: 
  - David Hugh-Jones
  - Tobias Edwards
abstract: |
  We investigate natural selection on polygenic scores
  in the contemporary US, using the Health and Retirement Study. Results
  partially support the economic theory of fertility as an explanation for
  scores which correlate negatively (positively) with education are
  selected for (against). Selection coefficients are larger among low-income
  and unmarried parents, but not among younger parents or those with less 
  education. We also estimate effect sizes corrected for noise in the 
  polygenic scores. 
  natural selection: among both white and black respondents,
date: "November 2023"
format: 
  pdf:
    keep-tex: true
    include-in-header:
      - text: |
          \usepackage{placeins}
    geometry:
    - top=2in
    - left=1.25in
    - right=1.25in
    - heightrounded
editor: visual
editor_options: 
  chunk_output_type: console
knitr:
  opts_chunk: 
    echo: false
bibliography: bibliography-hrs.bib
---

```{r}
#| label: setup


# TE quick TODOs change reference to time being insignificant. Fix the footnote citations
options(digits = 3)
set.seed(271075)

library(tibble)
library(haven)
library(forcats)
library(dplyr, warn.conflicts = FALSE)
library(glue)
library(stringr)
library(purrr)
library(carData)
library(car, warn.conflicts = FALSE) # masks some
library(ggplot2)
library(tidyr)
library(santoku, warn.conflicts = FALSE) # masks tidyr::chop
 # masks dotchart:
suppressPackageStartupMessages(library(survey, warn.conflicts = FALSE))

knitr::knit_hooks$set("inline", 
  \(x) {
    if (! is.na(x <- suppressWarnings(as.numeric(x)))) {
      x <- prettyNum(formatC(x, digits = 3, format = "f"), ",")
    }
    x
  }
)
nice_names <- c(
  SCZ = "Schizophrenia",
  WC = "Waist circ.",
  WHR = "Waist-hip ratio",
  NEUROT = "Neuroticism",
  WELLB = "Well-being",
  DEPSYMP = "Depr. symptoms",
  CD = "Cor. art. disease",
  MI = "Myoc. infarction",
  CORT = "Cortisol",
  T2D = "Type 2 diabetes",
  BIP = "Bipolar",
  ADHD_PGC17 = "ADHD",
  XDISORDER = "Cross-disorder",
  MENA = "Age at menarche",
  MENO = "Age at menopause",
  EXTRAVER = "Extraversion",
  AUTISM = "Autism",
  AB = "Antisoc. behav.",
  OCD = "OCD",
  AFBC = "Age 1st birth combn",
  AFBF = "Age 1st birth F",
  AFBM = "Age 1st birth M",
  MDD2 = "Maj. depr. disorder",
  PTSDAA = "PTSD Afr",
  PTSDEA = "PTSD Eur",
  PTSDC = "PTSD combined",
  HDL = "HDL cholesterol",
  LDL = "LDL cholesterol",
  TC = "Total cholesterol",
  ANXFS = "Anxiety factor",
  ANXCC = "Anxiety case-control",
  BUN = "Blood urea nitro.",
  BUNTE = "Blood urea nitro. TE",
  CKD = "Kidney disease",
  CKDTE = "Kidney disease TE",
  DBP = "Diastolic blood pr.",
  BMI2 = "BMI",
  HEIGHT2 = "Height",
  AI = "Age smoking init.",
  CPD_GSCAN19 = "Cigs per day",
  DPW = "Drinks per week",
  SC = "Smoking cessation",
  SI = "Smoking initiation",
  HTN = "Hypertension",
  CANNABIS = "Cannabis",
  GWAD2NA = "Alzheimer's no APOE",
  ALZ_01AD2NA = "Alzheimer's p 0.01 no APOE",
  GWAD2WA = "Alzheimer's",
  ALZ_01AD2WA = "Alzheimer's p 0.01",
  ALC = "Alcohol dependence",
  PP = "Pulse pressure",
  SBP = "Systolic blood pr.",
  EGFR = "Glom. filtr.",
  EGFRTE = "Glom. filtr. TE",
  EA3 = "Educ. attainment",
  HBA1CAA = "HbA1c Afr",
  HBA1CEA = "HbA1c Eur",
  GCOG2 = "Gen. cognition",
  ACTIVITY = "Physical Activity", # pgirep here
  ADHD = "ADHD",
  ADVENTURE = "Adventurous",
  AFB = "Age First Birth",
  ALLERGYCAT = "Cat Allergy",
  ALLERGYDUST = "Dust Allergy",
  ALLERGYPOLLEN = "Pollen Allergy",
  ASTECZRHI = "Asthma/Eczema/Rhinitis",
  ASTHMA = "Asthma",
  AUDIT = "Alcohol Misuse",
  BMI = "Body Mass Index",
  CANNABISpgirep = "Cannabis Use",
  COGEMP = "Cognitive Empathy",
  COPD = "Chronic Obstructive Pulmonary Disease",
  CPD = "Cigarettes per Day",
  CP = "Cognitive Performance",
  DELAYDISC = "Delay Discounting",
  DEP = "Depressive Symptoms",
  DPWpgirep = "Drinks per Week",
  EA = "Educational Attainment",
  EVERSMOKE = "Ever Smoker",
  EXTRA = "Exraversion",
  FAMSAT = "Satisfaction with Family",
  FINSAT = "Satisfaction with Finances",
  FRIENDSAT = "Satisfaction with Friends",
  HAYFEVER = "Hayfever",
  HEIGHTpgirep = "Height",
  HIGHMATH = "Highest Math",
  LEFTOUT = "Left Out of Social Activity",
  LONELY = "Loneliness",
  MENARCHE = "Age First Menses",
  MIGRAINE = "Migraine",
  MORNING = "Morning Person",
  NARCIS = "Narcissism",
  NEARSIGHTED = "Nearsightedness",
  NEBmen = "Number of Children (men)",
  NEBwomen = "Number of Children (women)",
  NEURO = "Neuroticism",
  OPEN = "Openness",
  READING = "Age Started Reading",
  RELIGATT = "Religious Attendance",
  RISK = "Risk Tolerance",
  SELFHEALTH = "Self-Rated Health",
  SELFMATH = "Self-Rated Math Ability",
  SWB = "Subjective Well-Being",
  VOICEDEEP = "Age Voice Deepened",
  WORKSAT = "Satisfaction with Work"
)

eths <- c("white", "black")

titles <- c(white = "White", black = "Black")


shorten <- function (x) {
  x <- str_remove(x, "^(A4|E4)_")
  x_short <- str_remove(x, "_.*")

  duplicates <- table(x_short)
  duplicates <- names(duplicates)[duplicates > 1]
  x_short[x_short %in% duplicates] <- x[x_short %in% duplicates]

  x_short <- str_replace(x_short, "^01", "ALZ_01") # two alzheimer's variants
  x_short
}


calc_income <- function (x, eth) {
  x <- x |> filter(ethnicity == eth)
  ages <- x |> select(matches("r\\d+agey_e"))
  income <- x |> select(matches("r\\d+iearn"))
  income <- rowMeans(income, na.rm = TRUE)
  mod <- lm(income ~ factor(x$rabyear), weights = x$weight, na.action =
              na.exclude)
  income_r <- resid(mod)
  income_r <- income_r - min(income_r, na.rm = TRUE) + 1

  income_r
}


calc_n <- function (mods, eths = "white", format = "(N = %s)") {
  nobs <- map_dbl(eths, \(x) nobs(mods[[x]][[1]]) ) 
  if (! is.null(format)) nobs <- sprintf(format, nobs)
  names(nobs) <- eths
  nobs
}


# avoid warnings about zero weights
svyglm_quiet <- function (...) suppressWarnings(svyglm(...))


# for a confidence interval
significant <- function (x) {
  stopifnot(is.numeric(x), length(x) == 2)
  all(x < 0) || all(x > 0)
}


insignificant <- Negate(significant)


# rand HRS longit data. VERY BIG
# Done just once:
# rand_orig <- haven::read_dta("data/randhrs/randhrs1992_2020v1.dta")
# saveRDS(rand_orig, file = "data/randhrs/rand-orig.rds", compress = FALSE)
rand_orig <- readRDS("data/randhrs/rand-orig.rds")

# ragender: 1 male, 2 female
rand_orig <- filter(rand_orig, 
                    (rabyear <= 1965 & ragender == 1) |
                    (rabyear <= 1970 & ragender == 2))

# african ancestry
pgen4a <- haven::read_dta("data/PGENSCORE4r3/pgenscore4a_r.dta")
# european ancestry
pgen4e <- haven::read_dta("data/PGENSCORE4r3/pgenscore4e_r.dta")

# TE edit PGI repository EUR only
pgirep <- readr::read_tsv("data/pgi-repository/HRS_PGIrepo_v1.0.txt",
                          show_col_types = FALSE)
names(pgirep)[1:2] <- c("hhid","pn")

pgirep <- pgirep |> 
  select(hhid, pn, matches("single"), -PGI_NEBwomen_single) |> 
  rename_with(
    \(x) str_replace(x, "PGI_(.*)_single", "\\1")
  )

# TE PGI rep does not come pre-standardised. Going to standardize over whole sample to match
# the approach taken with PGENscores
pgirep[, 3:ncol(pgirep)] <- scale(pgirep[, 3:ncol(pgirep)])

# original HRS tracker file
trk_orig <- haven::read_dta("data/trk2020v3/trk2020tr_r.dta")
trk_weights <- trk_orig |> select(HHID, PN, matches("BIOWGTR"))

# rand family respondents file
# Done just once:
# rand_fam <- haven::read_dta(
#   "data/randhrsfam1992_2018v2_STATA/randhrsfamr1992_2018v2.dta")
# saveRDS(rand_fam, "data/randhrsfam1992_2018v2_STATA/rand_fam.rds")
rand_fam <- readRDS("data/randhrsfam1992_2018v2_STATA/rand_fam.rds")
# only selected columns to avoid creating suffixes when we join with
# rand.
# Age of oldest kid; grandchildren; num siblings who died
rand_fam <- rand_fam |> select(hhid, pn, h10ageokid, h10gkid, r10sbdied)

# 2010 (and others) record "age started smoking"
# rand_2010 <- haven::read_dta("data/hd10f6a_STATA/hd10f6a.dta")
# saveRDS(rand_2010, "data/hd10f6a_STATA/rand_2010.rds")
rand_2010 <- readRDS("data/hd10f6a_STATA/rand_2010.rds")
rand_2010 <- rand_2010 |> 
  select(hhid, pn, mc120, matches("mlb041")) |> 
  mutate(
    age_smoked = ifelse(mc120 %in% c(95, 98, 99), NA_real_, mc120)
  )
rand_2010$anxiety <- rand_2010 |> 
  select(matches("mlb041")) |> 
  rowMeans(na.rm = TRUE)
rand_2010$anx_na <- rand_2010 |> 
  select(matches("mlb041")) |> 
  is.na() |> 
  rowSums()
# matches the documentation at 
# https://hrs.isr.umich.edu/sites/default/files/biblio/HRS2006LBQscale.pdf :
rand_2010$anxiety[rand_2010$anx_na > 2] <- NA_real_

# 2016 survey had a module with 18 questions diagnosing adult ADHD
# rand_2016 <- haven::read_dta("data/h16f2c_STATA/h16f2c.dta")
# saveRDS(rand_2016, "data/h16f2c_STATA/rand_2016.rds")
rand_2016 <- readRDS("data/h16f2c_STATA/rand_2016.rds")
rand_2016 <- rand_2016 |> 
  select(hhid, pn, pv001:pv018) |> 
  mutate(
    across(matches("pv\\d\\d\\d"), \(x) ifelse(x %in% 8:9, NA, x)),
    across(matches("pv\\d\\d\\d"), \(x) x == 1) # 1 is "yes', 5 is "no"
  )
rand_2016$adhd_score <- rand_2016 |> 
  select(pv001:pv018) |> 
  rowSums(na.rm = TRUE)
rand_2016$adhd_nas <- rand_2016 |> 
  select(pv001:pv018) |> 
  is.na() |> 
  rowSums(na.rm = TRUE)
rand_2016$adhd_score <- rand_2016$adhd_score/(18 - rand_2016$adhd_nas)

pgens <- list(white = pgen4e, black = pgen4a)

pcs <- c(paste0("PC1_5", LETTERS[1:5]), paste0("PC6_10", LETTERS[1:5]))

rands <- list()

for (eth in eths) {
  pgen <- pgens[[eth]]
  names(pgen) <- shorten(names(pgen))
  rands[[eth]] <- inner_join(rand_orig, pgen,
                     join_by(hhid, pn),
                     unmatched = "drop",
                     relationship = "one-to-one")
}


rand <- list_rbind(rands, names_to = "ethnicity")

old_pgs <- c("EDU2", "EDU3", "HEIGHT", "BMI",
           "AD", "AD2", "GENCOG", "EVRSMK", "LONG", "CPD_TAG10",
           "ADHD_PGC10", "MDD")

# TE going to simplify names of pgen4e. Then merge, then create pgs.
pgen4e_new_names <- pgen4e |>
    rename_with(shorten) |> 
    # weird that we have to operate on whole df to use select semantics
    select(-version,
           -matches("^PC\\d"),
           -matches("^NEB"), # number ever born
           # outdated, or EDU3 without 23andMe:
           -any_of(old_pgs)
           ) 

pgen4e_new_names <- left_join(pgen4e_new_names, pgirep, 
                              by = join_by(hhid == hhid, pn == pn),
                              suffix = c("", "pgirep"))

# Height is a duplicated name, but it's with the old PGS, so fixing this manually
pgen4e_new_names <- rename(pgen4e_new_names, 
                           HEIGHTpgirep = HEIGHT)

# TE here we removed pgenscores that are duplicated in the pgi repository
# we also remove trans ethnic and African ancestry PGS
dupe_PGS <- c("EA3", # TE when I've tested it the pgirep one is slightly better...
              "GCOG2", #CP
              "BMI2",
              "NEUROT",
              "WELLB",
              "DEPSYMP",
              "ADHD_PGC17",
              "EXTRAVER",
              "AFBC", 
              "PTSDAA", # African    
              "PTSDC", # Combined Euro + African.
              #"ANXFS"  ,"ANXCC", continuous vs case-control anxiety 
              # r = 0.6 let's keep them
              # I suppose it's equivalent to having CP and EA
              "BUNTE",  
              "CKDTE", 
              "BMI2",
              "HEIGHT2",
              "CPD_GSCAN19",
              "DPW",
              "SI",
              "CANNABIS", 
              "GWAD2NA", 
              "ALZ_01AD2NA",
              "GWAD2WA", # Three alzheimers deleted. Ones using p value 1 threshold
              # and alzheimers that remove APOE variant region
              "ALC", #AUDIT is alcohol misuse in pgirep
 	            "EGFR",
	            "HBA1CEA" 
              )


dupe_PGS_black <- c("PTSDAA",   
              "PTSDC", 
              "BUNTE", 
              "CKDTE", 
              "BMI2",
              "CANNABIS", 
              "GWAD2NA", 
              "ALZ_01AD2NA",
              "GWAD2WA", 
 	            "EGFR",
	            "HBA1CEA" 
              )
              
pgen4e_new_names <- select(pgen4e_new_names, 
                           -hhid, -pn, -any_of(dupe_PGS), -any_of(old_pgs))
pgs_white <- names(pgen4e_new_names)
pgs_white[pgs_white == "HEIGHT"] <- "HEIGHTpgirep"

pgs_black <- pgen4a |>
    rename_with(shorten) |> 
    select(-hhid, -pn, -version,
           -matches("^PC\\d"),
           -matches("^NEB"), # number ever born
           # outdated, or EDU3 without 23andMe:
           -any_of(old_pgs),
           -any_of(dupe_PGS_black)
           ) |>
    names()

rand <- left_join(rand, pgirep, by = join_by(hhid, pn),suffix=c("","pgirep"))

# weighting
rand <- left_join(rand, trk_weights, by = join_by(hhid == HHID, pn == PN))
rand$weight <- ifelse(is.na(rand$MBIOWGTR), rand$NBIOWGTR, rand$MBIOWGTR)

# TE I'm replacing 0 weights with NA because it can create odd problems
rand$weight <- na_if(rand$weight, 0)

# compensate for fecund parents more likely to have child in survey.
# we use living sibs rather than including dead sibs too here. we think that's
# the correct approach:
rand$parent_weight <- rand$weight / (rand$r10livsib + 1)
rand$child_weight <- rand$weight*rand$raevbrn


rand <- rand |> left_join(rand_fam, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

rand <- rand |> left_join(rand_2016, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

rand <- rand |> left_join(rand_2010, 
                          by = join_by(hhid, pn),
                          unmatched = "drop",
                          relationship = "one-to-one")

# TE this is average number of kids that your kids have
rand$div_h10gkid <- rand$h10gkid / rand$raevbrn


# 83 people report having grandkids, but having had no children. Weird!
# This code subsets the data by ethnicity then counts all observations
# where grandkids is greater than 0 but number of kids is 0
gkids_unusable_white <- rand |> 
  filter(ethnicity == "white", h10gkid > 0, raevbrn == 0) |> 
  nrow()
gkids_unusable_black <- rand |> 
  filter(ethnicity == "black", h10gkid > 0, raevbrn == 0) |> 
  nrow()

# if grandkids but no kids div_gkid is infinite. Replacing with NA
rand$div_h10gkid[is.infinite(rand$div_h10gkid)] <- NA

rand <- rand |>
  mutate(.by = rabyear, # calculate this pooling ethnicity
    mean_weight = mean(weight, na.rm = TRUE),
    mean_child_weight = mean(child_weight, na.rm = TRUE),
    mean_raevbrn = mean(raevbrn*weight/mean_weight, na.rm = TRUE),
    rlrs = raevbrn/mean_raevbrn,
    mean_h10gkid = mean(h10gkid*weight/mean_weight, na.rm = TRUE),
    rlrs_h10gkid = h10gkid/mean_h10gkid,
    mean_div_h10gkid = mean(div_h10gkid*child_weight/mean_child_weight, 
                            na.rm = TRUE), 
    rlrs_div_h10gkid = div_h10gkid/mean_div_h10gkid
  ) |>
  mutate(.by = ethnicity, # calculate these stats within-ethnicity
    income_resid = calc_income(rand, ethnicity[1]),
    income_resid = income_resid - min(income_resid, na.rm = TRUE) + 1,
    income_med = chop_equally(income_resid, 2, labels = c("Low", "High")),
    # as.numeric avoids haven.labelled issues:
    raedyrs = as.numeric(raedyrs),
    r10hearte = as.numeric(r10hearte),
    r10diabe = as.numeric(r10diabe),
    edu = chop(as.numeric(raedyrs), 13, lbl_discrete(symbol = "-")),
    born = chop(rabyear, 1942, labels = c("pre-1942", "post-1942")),
    # wave 10 is 2010
    # table(rands$white$r10mstat)
     # 1                 1.married
     # 2   2.married,spouse absent
     # 3               3.partnered
     # 4               4.separated
     # 5                5.divorced
     # 6      6.separated/divorced
     # 7                 7.widowed
     # 8           8.never married
    married = factor(r10mstat == 1, 
                     levels = c(FALSE, TRUE),
                     labels = c("Other", "Married")),
    r10sibs = r10livsib + 1, # n. sibs including oneself!
    agefbn = r10agey_e - h10ageokid,
    agefbn = ifelse(agefbn < 12, NA_real_, agefbn),
  ) |> 
  mutate(.by = c(ethnicity, ragender),
    agefb = chop_equally(agefbn, 2, labels = c("Low", "High"))
  )

# TE I've plotted the mean values by year. They look reasonably stable. Beauchamp 2016 took a three year average. I don't think this is necessary

rand$neurot <- rand |> 
  select(matches("r\\d+lbneur")) |> 
  rowMeans(na.rm = TRUE)
# two of four Alzheimer's variants with awkward names:
#pgs <- str_replace(pgs, "^01", "ALZ_01")
pgs_white <- str_replace(pgs_white, "^01", "ALZ_01")
pgs_black <- str_replace(pgs_black, "^01", "ALZ_01")
names(rand) <- str_replace(names(rand), "^01", "ALZ_01")
pgs <- unique(c(pgs_white,pgs_black))

```

```{r}
#| label: prog-cleanup


# clean up cache so it doesn't get too big
rm(rand_orig, trk_orig, rands, rand_fam, rand_2010, rand_2016)

# TE we can delete more
rm(pgen, pgen4a, pgen4e, pgirep, trk_weights)

rand <- rand |> 
  select(ethnicity, all_of(pgs), all_of(old_pgs), 
         all_of(pcs), weight, raevbrn, rlrs,
         raedyrs, r10sibs, edu, income_resid, income_med, married, 
         agefb, agefbn, rabyear, born, raehsamp, raestrat, 
         parent_weight, ragender, adhd_score, neurot, r10diabe, 
         r10hearte, r10cesd, age_smoked, anxiety, r10cogtot, 
         rlrs_div_h10gkid, child_weight)

r_parents <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ parent_weight, 
		nest = TRUE,
		data = rand |> drop_na(parent_weight) 
		)

r_child <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ child_weight, 
		nest = TRUE,
		data = rand |> drop_na(child_weight) 
		)

rand <- svydesign(
    id = ~ raehsamp,
		strata = ~ raestrat,
		weights = ~ weight, 
		nest = TRUE,
		data = rand |> drop_na(weight) 
		)

n_white <- nrow(rand |> subset(ethnicity == "white"))
n_black <- nrow(rand |> subset(ethnicity == "black"))

```

@hugh2022human explain patterns of natural selection on polygenic scores in the UK, using an economic theory of fertility derived from @becker1976child. The theory has two components.

1.  There is a trade-off between time spent working and raising children. This leads people with more human capital and higher expected wages to have fewer children. Evidence for this is that polygenic scores which correlate positively with human capital correlate negatively with number of children, i.e. they are being selected against; conversely, scores which correlate positively with human capital are being selected for.
2.  The trade-off is sharper for low-income people, people with low human capital, and single parents. As a result, natural selection is stronger among these groups. Evidence for this is that scores' regression coefficients on number of children are larger among people with lower income or less education, and single parents.

Here, we make an independent test of the theory in the US population, using the Health and Retirement Survey [@hrsrandfam2023; @hrsrand2023]. The HRS is more representative of the population than UK Biobank, which addresses one potential weakness of the previous paper. The HRS also provides precalculated polygenic scores [@hrspgs2020] for both black and (non-hispanic) white participants, so we can check whether the theory predicts patterns of natural selection in both these ethnicities.

# Data

The HRS sample focuses on cohorts born between 1920 and 1960, but contains some younger and older participants. we include only male participants born before 1965 and female participants born before 1970, which guarantees that most will have completed their fertility by 2010. The resulting sample contains `r n_white` genotyped white participants and `r n_black` genotyped black participants.

<!--#  TE sources of pgs are not mentioned in the data section. I've added that since we are now using two sources -->

Genotyping took place in 2006, 2008 and subsequent years. PGS were taken from those pre-calculated by the HRS [@hrspgs2020] and those produced by the Social Science Genetic Association Consortium, as part of their Polygenic Index Repository [@becker2021resource]. Scores created by the HRS were provided for black and white participants, but Polygenic Index Repository scores were only created for white participants.

For the white participants, when scores from the two samples measured the same trait, we only used the PGS from the Polygenic Index Repository. For some traits, polygenic scores were created from European ancestry GWAS and GWAS with samples of different ancestry. We choose to use polygenic scores trained only on individuals of European ancestry. We discard obsolete PGS for which there is a newer, more accurate score targeting the same phenotype. we also discard PGS for number of children ever born (but keep scores for age at first birth). This leaves a total of `r length(pgs_white)` scores for the white participants and `r length(pgs_black)` for the black participants. PGS are rescaled to zero mean and unit variance within each ethnic group, so coefficient sizes are not directly comparable between ethnic groups, but are measured in standard deviations of the within-ethnic-group score. In all regressions using PGS, we control for ten within-ethnicity principal components of the DNA array data.

The key dependent variable is relative lifetime reproductive success (RLRS): number of children ever born, divided by mean number of children of people born in the same year. RLRS is calculated pooling ethnicities, i.e. treating them as members of the same biological population. The mean number of children of people born in the same year was calculated using sampling weights.

The HRS contains weights which match survey respondents to the US population. We use weights for the biomarker subsample (\*BIOWGTR in the HRS tracker file). Since half the sample enters the extended interview including biomarker data in each biannual survey, we weight individuals by either their 2010 weight or their 2012 weight. This maximizes the available sample of both black and white respondents, and should approximately match the US population of the sample cohorts between 2010 and 2012. Statistical tests are adjusted for clustering and stratification using the R "survey" package [@lumleysurvey2023].

# Results

```{r}
#| label: stat-regressions

# cache seems to cause trouble even with cache-lazy: FALSE 

tidy_pgs <- mod_pgs <- list()
tidy_pgs_ed <- mod_pgs_edyrs <- list()
tidy_pgs_sibs <- mod_pgs_sibs <- list()
tidy_pgs_gkids <- mod_pgs_gkids <- list()
tidy_pgs_x_ed <- mod_pgs_x_ed <- list()
tidy_pgs_x_inc <- mod_pgs_x_inc <- list()
tidy_pgs_x_mar <- mod_pgs_x_mar <- list()
tidy_pgs_x_agefb <- mod_pgs_x_agefb <- list()

coefs_fert_edu <- cors_fert_edu <- tidy_pgs_joined <- list()
cors_sibs_edu <- list()
cors_gkids_edu <- list()
tidy_fert_edu_phen <- list()

for (eth in eths) {
  
  if (eth == "white") {
    pgs <- pgs_white
  } else {
    pgs <- pgs_black
  }
  

  r_eth <- rand |> subset(ethnicity == eth)
  r_parents_eth <- r_parents |> subset(ethnicity == eth)
  r_child_eth <- r_child |> subset(ethnicity == eth)
  
  form_pgs <- map(pgs, \(x) reformulate(c(x, pcs), response = "rlrs"))
  mod_pgs[[eth]] <- map(form_pgs, 
                               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs[[eth]] <- mod_pgs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |> 
    list_rbind() |>
    filter(term %in% pgs)
  
  form_pgs_edyrs <- map(pgs, \(x) reformulate(c(x, pcs),
                                              response = "raedyrs"))
  mod_pgs_edyrs[[eth]] <- map(form_pgs_edyrs, 
                                     \(x) svyglm_quiet(x, r_eth))
  names(mod_pgs_edyrs[[eth]]) <- pgs
  
  tidy_pgs_ed[[eth]] <- mod_pgs_edyrs[[eth]] |>  
    map(broom::tidy) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  tidy_pgs_joined[[eth]] <- inner_join(tidy_pgs[[eth]], tidy_pgs_ed[[eth]],
                                by = join_by(term),
                                unmatched = "error",
                                suffix = c(".fert", ".edyrs"),
                                relationship = "one-to-one")
  cors_fert_edu[[eth]] <- cor(tidy_pgs_joined[[eth]]$estimate.edyrs, 
                     tidy_pgs_joined[[eth]]$estimate.fert)
  coefs_fert_edu[[eth]] <- lm(estimate.fert ~ estimate.edyrs,
                              data = tidy_pgs_joined[[eth]]) |> 
                           coef() |> 
                           pluck("estimate.edyrs")
  
  form_pgs_sibs <- map(pgs, 
                       \(x) reformulate(c(x, pcs), response = "r10sibs"))
  mod_pgs_sibs[[eth]] <- map(form_pgs_sibs,
                                    \(x) svyglm_quiet(x, r_parents_eth))
  
  tidy_pgs_sibs[[eth]] <- mod_pgs_sibs[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  cors_sibs_edu[[eth]] <- cor(tidy_pgs_sibs[[eth]]$estimate, 
                     tidy_pgs_ed[[eth]]$estimate)
  
  
  
    form_pgs_gkids <- map(pgs, 
                       \(x) reformulate(c(x, pcs), response = "rlrs_div_h10gkid"))
  mod_pgs_gkids[[eth]] <- map(form_pgs_gkids,
                                    \(x) svyglm_quiet(x, r_child_eth))
  
  tidy_pgs_gkids[[eth]] <- mod_pgs_gkids[[eth]] |> 
    map(broom::tidy, conf.int = TRUE, conf.level = 0.95) |>
    list_rbind() |> 
    filter(term %in% pgs)
  
  cors_gkids_edu[[eth]] <- cor(tidy_pgs_gkids[[eth]]$estimate, 
                     tidy_pgs_ed[[eth]]$estimate)
  

  tidy_fert_edu_phen[[eth]] <- 
    svyglm_quiet(rlrs ~ raedyrs, r_eth) |> 
    broom::tidy(conf.int = TRUE) |> 
    filter(term == "raedyrs")
}

# we only look at interactions among whites, the rest is pointless
for (eth in "white") {
  r_eth <- rand |> subset(ethnicity == eth)
  
  
  if (eth == "white") {
    pgs <- pgs_white
  } else {
    pgs <- pgs_black
  }
  
  # the colon interaction estimates the effect separately within each group
  form_pgs_x_ed <- paste0(pgs, ":edu") |>
    map(\(x) reformulate(c(x, "edu", pcs), response = "rlrs"))
  mod_pgs_x_ed[[eth]]  <-
    map(form_pgs_x_ed, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_ed[[eth]] <-
    map(mod_pgs_x_ed[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_ed[[eth]]) <- pgs
  tidy_pgs_x_ed[[eth]] <-
    list_rbind(tidy_pgs_x_ed[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "edu13-17", pcs)) |>
    mutate(edu = str_remove(term, ".*:"))
  
  form_pgs_x_inc <- paste0(pgs, ":income_med") |>
    map(\(x) reformulate(c(x, "income_med", pcs), response = "rlrs"))
  mod_pgs_x_inc[[eth]]  <-
    map(form_pgs_x_inc, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_inc[[eth]] <-
    map(mod_pgs_x_inc[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_inc[[eth]]) <- pgs
  tidy_pgs_x_inc[[eth]] <-
    list_rbind(tidy_pgs_x_inc[[eth]], names_to = "pgs") |>
    filter(!term %in% c("(Intercept)", "income_medHigh", pcs)) |>
    mutate(income_med = str_remove(term, ".*:income_med"))
  
  form_pgs_x_mar <- paste0(pgs, ":married") |>
    map(\(x) reformulate(c(x, "married", pcs), response = "rlrs"))
  mod_pgs_x_mar[[eth]]  <-
    map(form_pgs_x_mar, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_mar[[eth]] <-
    map(mod_pgs_x_mar[[eth]], broom::tidy, conf.int = TRUE)
  names(tidy_pgs_x_mar[[eth]]) <- pgs
  tidy_pgs_x_mar[[eth]] <-
    list_rbind(tidy_pgs_x_mar[[eth]], names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "marriedMarried", pcs)) |>
    mutate(
      married = str_remove(term, ".*:married")
    ) 
  
  form_pgs_x_agefb <- paste0(pgs, ":agefb") |>
    map(\(x) reformulate(c(x, "agefb", pcs), response = "rlrs"))
  mod_pgs_x_agefb[[eth]]  <-
    map(form_pgs_x_agefb, 
               \(x) svyglm_quiet(x, r_eth))
  
  tidy_pgs_x_agefb[[eth]] <-
    map(mod_pgs_x_agefb[[eth]], broom::tidy, conf.int = TRUE) |> 
    setNames(pgs) |> 
    list_rbind(names_to = "pgs") |>
    filter(! term %in% c("(Intercept)", "agefbHigh", pcs)) |>
    mutate(
      agefb = str_remove(term, ".*:agefb")
    ) 
}

tidy_pgs_eth <- list_rbind(tidy_pgs)
n_tests <- nrow(tidy_pgs_eth)
n_sig_bonf <- sum(tidy_pgs_eth$p.value < 0.05/n_tests)

# TE bonferroni correction might make more sense focusing on white tests
# Either way seems to produce the same result

n_tests_white <- nrow(tidy_pgs$white)
n_sig_bonf_white <- sum(tidy_pgs$white$p.value < 0.05/n_tests)

n_tests_black <- nrow(tidy_pgs$black)
n_sig_bonf_black <- sum(tidy_pgs$black$p.value < 0.05/n_tests)


```

```{r}
#| label: stat-bootstrap-eth-cor
#| cache: true
#| cache-lazy: false
#| eval: false

# I don't mention this below so turning it off for now
# TODO: should I mention it? It's a low correlation.

n_reps_eth_diff <- 199
rand_boot <- rand |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_eth_diff)


calc_eth_cor <- function (weights, data) {
  coef_pgs_white <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "white")) |> 
        map2_dbl(pgs, \(x, y) coef(x)[[y]])
  coef_pgs_black <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "black")) |> 
        map2_dbl(pgs, \(x, y) coef(x)[[y]])
  
  c(cor = cor(coef_pgs_black, coef_pgs_white))
}


cor_eths <- cor(tidy_pgs$white$estimate, tidy_pgs$black$estimate)
cor_eths_boot <- withReplicates(rand_boot, theta = calc_eth_cor)
ci_eths <- confint(cor_eths_boot)[1,]
```

<!--# TE edited because 3 scores are bonferroni significant in whites. As of writing the same same three scores were signficiant regardlesss of whether we pool the blacks and whites in the bonferroni calculation.-->

We estimated coefficients of PGS on RLRS among black and white respondents separately. These are not meant to identify causal effects; recall that natural selection involves correlation, not necessarily causation, between selected characteristics and fertility. Appendix @fig-rlrs shows coefficients for white respondents only; power is too low for individual PGS estimates to be informative in the black sample. Standard errors are large because of the relatively low sample sizes. `r n_sig_bonf` scores are significant at Bonferroni-corrected p \< 0.05/`r n_tests`. The scores are age at first birth, educational attainment and attention deficit disorder. But we are most concerned with looking at patterns across scores rather than judging the significance of individual scores.

```{r}
#| label: stat-bootstraps
#| cache: true
#| cache-lazy: false
#| cache-comments: false


# Not sure this actually does anything :-)
old_opts <- options(survey.multicore = TRUE) 

# The large n_reps is to get an accurate upper tail on the black sample, 
# since it is close to 0:
n_reps <-  599

calc_cors_edu <- function (weights, data, var) {
  coef_pgs_fert <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = var)) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  coef_pgs_edu <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "raedyrs")) |> 
        map(\(x) lm(x, data, weights = weights)) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  c(
    cor = cor(coef_pgs_edu, coef_pgs_fert),
    coef = coef(lm(coef_pgs_fert ~ coef_pgs_edu))["coef_pgs_edu"]
  )
}
  

cors_fert_edu <- cors_sibs_edu <- list()
for (eth in eths) {
  
  
  if (eth == "white") {
    pgs <- pgs_white
  } else {
    pgs <- pgs_black
  }
  
  
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  r_parents_boot <- r_parents |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  r_child_boot <- r_child |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps)
  
  cors_fert_edu[[eth]] <- 
    withReplicates(rand_boot, theta = calc_cors_edu, var = "rlrs")
  cors_sibs_edu[[eth]] <- 
    withReplicates(r_parents_boot, theta = calc_cors_edu, var = "r10sibs")
  cors_gkids_edu[[eth]] <- 
    withReplicates(r_child_boot, theta = calc_cors_edu, var = "rlrs_div_h10gkid")
}

options(old_opts)
```

```{r}
#| label: stat-bootstrap-eth-diff
#| eval: false

# this was an attempt to see if black coefs were larger in abs size than
# white coefs. Results were always absolutely insignificant (and conf
# intervals too wide to be informative).

n_reps_eth_diff <- 199
rand_boot <- rand |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_eth_diff)


calc_eth_diff <- function (weights, data) {
  coef_pgs_white <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "white")) |> 
        map_dbl(\(x) coef(x)[[2]])
  coef_pgs_black <- pgs |> 
        map(\(x) reformulate(c(x, pcs), response = "rlrs")) |> 
        map(\(x) lm(x, data, weights = weights, 
                    subset = ethnicity == "black")) |> 
        map_dbl(\(x) coef(x)[[2]])
  
  # this is positive if white was "bigger" than black taking the white sign 
  # as the correct sign. Negative if b was "bigger"  than w.
  diff_coefs <- (coef_pgs_white - coef_pgs_black)*sign(coef_pgs_white)
  names(diff_coefs) <- pgs
  c(diff = mean(diff_coefs))
}

diff_eths <- withReplicates(rand_boot, theta = calc_eth_diff)
```

```{r}
#| label: stat-post-bootstraps

# separate so we don't interfere with the bootstrap cache

ci_boot_fert <- map(cors_fert_edu, \(x) confint(x)[1,])
ci_boot_sibs <- map(cors_sibs_edu, \(x) confint(x)[1,])
ci_boot_gkids <- map(cors_gkids_edu, \(x) confint(x)[1,])

ci_boot_fert_lm <- map(cors_fert_edu, \(x) confint(x)[2,])
ci_boot_sibs_lm <- map(cors_sibs_edu, \(x) confint(x)[2,])
ci_boot_gkids_lm <- map(cors_gkids_edu, \(x) confint(x)[2,])

if (insignificant(ci_boot_fert$white)) warning("ci_boot_fert$white insignificant")
if (significant(ci_boot_fert$black)) warning("ci_boot_fert$black significant")
if (insignificant(ci_boot_sibs$white)) warning("ci_boot_sibs$white insignificant")
if (significant(ci_boot_sibs$black)) warning("ci_boot_sibs$black significant")
if (insignificant(ci_boot_gkids$white)) warning("ci_boot_gkids$white insignificant")
if (significant(ci_boot_gkids$black)) warning("ci_boot_gkids$black significant")
```

@fig-rlrs-edu plots each PGS's partial correlation with RLRS against its partial correlation with educational attainment. The relationship is negative among whites (correlation `r cors_fert_edu$white[1]`, bootstrap 95% C.I. `r ci_boot_fert$white[1]` to `r ci_boot_fert$white[2]`) and negative but insignificant among blacks (correlation `r cors_fert_edu$black[1]`, bootstrap 95% C.I. `r ci_boot_fert$black[1]` to `r ci_boot_fert$black[2]`). Survey bootstraps [@canty1999resampling] are used so as to make inferences from the sample of respondents.

```{r}
#| label: fig-rlrs-edu
#| fig-cap: |
#|   Scatterplot of PGS regression coefficients on RLRS against 
#|   coefficients on years of education. Each dot is one polygenic score.
#|   Controls include 10 principal components of genetic array
#|   data. Dashed lines are fitted from linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <- ggplot(tidy_pgs_joined[[eth]], aes(estimate.edyrs, estimate.fert)) +
          geom_hline(yintercept = 0, color = "grey80") +
          geom_vline(xintercept = 0, color = "grey80") +
          geom_point() +
          geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                      linetype = "dashed", colour = "red", linewidth = 0.5) +
          scale_y_continuous(breaks = seq(-0.2, 0.2, 0.02),
                             labels = scales::label_number(0.01)) +
          coord_cartesian(xlim = c(-.3, .75)) +
          theme_light() + 
          theme(panel.grid = element_blank()) +
          labs(
            title = titles[eth],
            x = "Coefficient on years of education",
            y = "Coefficient on RLRS"
          )
  print(ggp)
}

```

```{r}
#| label: stat-siblings

tmp <- 
  tidy_pgs_sibs$black |> 
  inner_join(tidy_pgs_ed$black, 
             by = join_by(term), 
             suffix = c(".sibs", ".edyrs")) |> 
  filter(term != "GWAD2NA", term != "GWAD2WA")

cor_no_outliers <- cor(tmp$estimate.sibs, tmp$estimate.edyrs)
# if (! cor_no_outliers < 0) stop("Correlation without outliers IS NOT neg.")
# TE correlation without outliers is not NEG
```

```{r}
#| label: stat-bootstrap-gen-cor
#| cache: true

n_reps_gen_cor <- 199
pgs <- pgs_white

f_resp <- map(pgs, \(x) reformulate(c(x, pcs), response = "raevbrn"))
f_sibs <- map(pgs, \(x) reformulate(c(x, pcs), response = "r10sibs"))
  
estimate_gen_cor <- function (w, data) {
  data$w <- w # avoid w getting lost by map and lm
  m_resp <- map(f_resp, \(x) lm(x, data, weights = w))
  m_sibs <- map(f_sibs, \(x) lm(x, data, weights = w/r10sibs))
  
  coef_resp <- map2_dbl(m_resp, pgs, \(x, y) coef(x)[[y]])
  coef_sibs <- map2_dbl(m_sibs, pgs, \(x, y) coef(x)[[y]])
  c(gen_cor = cor(coef_resp, coef_sibs))
}

rand_boot <- rand |> 
    subset(ethnicity == "white") |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_gen_cor)

gen_cor <- withReplicates(rand_boot, theta = estimate_gen_cor)
ci_gen_cor <- confint(gen_cor)
```

```{r}
#| label: stat-bootstrap-gen-cor-gkids
#| cache: true

n_reps_gen_cor <-  199
pgs <- pgs_white

f_resp <- map(pgs, \(x) reformulate(c(x, pcs), response = "rlrs"))
f_gkids <- map(pgs, \(x) reformulate(c(x, pcs), response = "rlrs_div_h10gkid"))
  
estimate_gen_cor <- function (w, data) {
  data$w <- w # avoid w getting lost by map and lm
  m_resp <- map(f_resp, \(x) lm(x, data, weights = w))
  m_gkids <- map(f_gkids, \(x) lm(x, data, weights = w*raevbrn))
  
  coef_resp <- map2_dbl(m_resp, pgs, \(x, y) coef(x)[[y]])
  coef_gkids <- map2_dbl(m_gkids, pgs, \(x, y) coef(x)[[y]])
  c(gen_cor = cor(coef_resp, coef_gkids))
}

rand_boot <- rand |> 
    subset(ethnicity == "white") |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_gen_cor)

gen_cor_gkids <- withReplicates(rand_boot, theta = estimate_gen_cor)
ci_gen_cor_gkids <- confint(gen_cor_gkids)

```

<!--# TE Added grandkids and fixed minor typos -->

We can also examine natural selection in the preceding and succeeding generations, by using reported number of siblings and grandchildren respectively. We regress PGS on respondents' number of living siblings in 2010. Data for dead siblings has too many missing values to use. We reweight respondents by the reciprocal of their number of siblings, to account for parents of many siblings being more likely to be a parent of a respondent. Parents of no siblings cannot be included, so coefficient sizes are not comparable across the generations. Appendix @fig-siblings plots coefficients on number of siblings versus coefficients on years of education. Correlations are only significant and negative in the white respondents, although ethnicities have large standard errors (whites: correlation `r cors_sibs_edu$white[1]`, bootstrapped 95% C.I. `r ci_boot_sibs$white[1]` to `r ci_boot_sibs$white[2]`; blacks: correlation `r cors_sibs_edu$black[1]`, bootstrapped 95% C.I. `r ci_boot_sibs$black[1]` to `r ci_boot_sibs$black[2]`). There is a positive and significant correlation across generations, i.e. between PGS coefficients on number of siblings and number of children (among whites: `r gen_cor`,cbootstrapped 95% C.I. `r ci_gen_cor[1,1]` to `r ci_gen_cor[1,2]`).

To examine selection in the succeeding generation, we divide the respondents' number of grandchildren by their number of children. In other words, we calculate the average number of children the respondent's children have. This measures the reproductive success in the second generation which we can call RS2. `r gkids_unusable_white` white respondents and `r gkids_unusable_black` black respondents report having grandchildren despite reporting having had no children. These individuals were removed for this test. In regression we reweight respondents by the number of children they have, since more fecund grandparents account for a larger proportion of the next generation. Older grandparents will have more time for their number of grandkids to accumulate. To deal with this time trend, we divide RS2 by the mean RS2 of respondents born in the same year, creating relative RS2 (RRS2).

We regress the respondent's (the grandparent's) PGS on RRS2. The resulting coefficient is only a proxy for selection in the next generation, not a perfect measure. The grandparent's PGS indicates, but does not determine the PGS of the parent. To know the expected parent's PGS, we would need both grandparent's PGS. Given that some respondents do not have a partner in the HRS and some have had children with multiple partners, such an approach is untenable in our sample. We expect the effect of the grandparent's PGS to also be dependent upon the level of assortative mating for the trait. For traits with high assortative mating, the grandparent's PGS will more strongly predict the parent's PGS, leading to a greater regression slope.

Appendix @fig-gkids plots coefficients on RRS2 versus coefficients on years of education. Correlations are significant for whites but not blacks. Standard errors were moderate in whites, but large in blacks (whites: correlation `r cors_gkids_edu$white[1]`, bootstrapped 95% C.I. `r ci_boot_gkids$white[1]` to `r ci_boot_gkids$white[2]`; blacks: correlation `r cors_gkids_edu$black[1]`, bootstrapped 95% C.I. `r ci_boot_gkids$black[1]` to `r ci_boot_gkids$black[2]`). There is a strong positive correlation between the parent and grandchild regressions, i.e. between PGS coefficients on RRS2 and RLRS (among whites: `r gen_cor_gkids`, bootstrapped 95% C.I. `r ci_gen_cor_gkids[1,1]` to `r ci_gen_cor_gkids[1,2]`).

We next test part 2 of the theory by interacting PGS with measures of education, income, marital status, and age at first birth. Education is years of education, split at 12 years. Income is respondent's mean wage income over all surveys, residualized on a full set of birth year dummies, and median-split. From here on we only use the white subsample: there are too few black respondents to be informative.

```{r}
#| label: stat-x-bootstrap-cors
#| cache: true
#| cache-lazy: false
#| eval: false

old_opts <- options(survey.multicore = TRUE) 

# all confindence intervals were too wide to be informative
n_reps_x <-  199

calc_diff_cor_ed <- function (w, data, term) {
  groups <- switch(term,
                edu = c("0-12", "13-17"),
                income_med = c("Low", "High"),
                married = c("Other", "Married"),
                agefb = c("Low", "High"))
  groups <- paste0(":", term, groups) # colon for the cross term
  low_group <- groups[1]
  high_group <- groups[2]
  
  forms <- paste0(pgs, ":", term) |>
    map(\(x) reformulate(c(x, term, pcs), response = "rlrs"))
  mods <- map(forms, \(x) lm(x, data, weights = w))
  cfs <- map(mods, coef)
  cfs_low <- map_dbl(cfs, \(x) x[str_detect(names(x), low_group)])
  cfs_high <- map_dbl(cfs, \(x) x[str_detect(names(x), high_group)])
  
  forms_ed <- paste0(pgs, ":", term)  |> 
    map(\(x) reformulate(c(x, term, pcs), response = "raedyrs"))
  mods_ed <- forms_ed |> map(\(x) lm(x, data, weights = w))
  cfs_ed <- map(mods_ed, coef)
  cfs_ed_low <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), low_group)])
  cfs_ed_high <- map_dbl(cfs_ed, \(x) x[str_detect(names(x), high_group)])
  
  cor_ed_low <- cor(cfs_low, cfs_ed_low)
  cor_ed_high <- cor(cfs_high, cfs_ed_high)
  
  c(low = cor_ed_low, high = cor_ed_high, diff = cor_ed_low - cor_ed_high)
}

diff_cor_ed <- ci <- est <- tbl <- list()

terms <- c("edu", "income_med", "married", "agefb")
for (eth in eths) {
  rand_boot <- rand |> 
    subset(ethnicity == eth) |> 
    as.svrepdesign(type = "bootstrap", replicates = n_reps_x)
  
  for (term in terms) {
    diff_cor_ed[[eth]][[term]] <- 
      withReplicates(rand_boot, theta = calc_diff_cor_ed, term = term)  
    ci[[eth]][[term]] <- confint(diff_cor_ed[[eth]][[term]])
    est[[eth]][[term]] <- as.numeric(diff_cor_ed[[eth]][[term]])
  }
}

options(old_opts)




```

```{r}
#| label: stat-x-bootstrap-effect-size
#| cache: true
#| cache-lazy: false
#| cache-comments: false


n_reps_x_es <-  199

calc_diff_effect_size <- function (w, data, term) {
  groups <- switch(term,
                edu = c("0-12", "13-17"),
                income_med = c("Low", "High"),
                married = c("Other", "Married"),
                agefb = c("Low", "High"),
                born = c("pre-1942", "post-1942"))
  groups <- paste0(":", term, groups) # colon for the cross term
  low_group <- groups[1]
  high_group <- groups[2]
  
  forms <- paste0(pgs, ":", term) |>
    map(\(x) reformulate(c(x, term, pcs), response = "rlrs"))
  mods <- map(forms, \(x) lm(x, data, weights = w))
  cfs <- map(mods, coef)
  cfs_low <- map_dbl(cfs, \(x) x[str_detect(names(x), low_group)])
  cfs_high <- map_dbl(cfs, \(x) x[str_detect(names(x), high_group)])
  
  abs_eff_low <- mean(abs(cfs_low))
  abs_eff_high <- mean(abs(cfs_high))
  diff_abs_eff <- abs_eff_low - abs_eff_high
  c(low = abs_eff_low, high = abs_eff_high, diff = diff_abs_eff)
}


effect_sizes <- ci <- est <- tbl <- list()

terms <- c("edu", "income_med", "married", "agefb", "born")

rand_boot <- rand |> 
  subset(ethnicity == "white") |> 
  as.svrepdesign(type = "bootstrap", replicates = n_reps_x_es)

for (term in terms) {
  effect_sizes[[term]] <- 
    withReplicates(rand_boot, theta = calc_diff_effect_size, term = term)  
  ci[[term]] <- confint(effect_sizes[[term]])
  est[[term]] <- as.numeric(effect_sizes[[term]])
  tbl[[term]] <- sprintf("%.3f (%.3f to %.3f)", est[[term]], 
                         ci[[term]][, 1], ci[[term]][, 2])
}



```

```{r}
#| label: stat-bootstrap-agefb
#| cache: true

n_reps_agefb <-  199

calc_cor_agefb <- function (w, data) {
  forms <- pgs |> map(\(x) reformulate(c(x, pcs), response = "raevbrn"))
  mods_low <- map(forms, \(x) lm(x, data, subset = agefb == "Low",
                                 weights = w))
  mods_high <- map(forms, \(x) lm(x, data, subset = agefb == "High",
                                  weights = w))
  coefs_low <- map2_dbl(mods_low, pgs, \(x, y) coef(x)[[y]])
  coefs_high <- map2_dbl(mods_high, pgs, \(x, y) coef(x)[[y]])
  
  c(
    cor = cor(coefs_low, coefs_high), 
    discordant = sum(sign(coefs_low) != sign(coefs_high)) # discordant pairs
  )
}

rand_boot <- rand |> 
  subset(ethnicity == "white") |> 
  as.svrepdesign(type = "bootstrap", replicates = n_reps_agefb)

cor_agefb <- withReplicates(rand_boot, theta = calc_cor_agefb)

stopifnot(insignificant(confint(cor_agefb)[1,]))
ci_discordant <- confint(cor_agefb)[2,]
# significantly different from 1/2?
stopifnot(ci_discordant[1] <= length(pgs)/2 && 
            ci_discordant[2] >= length(pgs)/2)


```

```{r}
#| label: stat-post-x-bootstrap

stopifnot(insignificant(ci$edu[3,]))
stopifnot(significant(ci$income_med[3,]))
stopifnot(significant(ci$married[3,]))
stopifnot(insignificant(ci$agefb[3,]))

tidy_agefb_wide <- tidy_pgs_x_agefb$white |> 
  pivot_wider(id_cols = pgs, names_from = agefb, values_from = estimate)

cor_agefb <- cor(tidy_agefb_wide$Low, tidy_agefb_wide$High)
n_discordant <- sum(sign(tidy_agefb_wide$Low) != sign(tidy_agefb_wide$High))
```

Appendix @fig-x-edu shows essentially no difference in the distribution of absolute coefficient sizes between respondents with more and less education. Appendix @fig-x-inc, on the other hand, shows that coefficients appear larger among lower-income respondents. Appendix @fig-x-mar shows absolute coefficients for respondents who were married in 2010 against all other statuses. Coefficients appear larger for unmarried respondents.

Appendix @fig-x-agefb splits respondents by age at first birth (median within each gender). Note that the N is lower here due to missing values. There are no large differences in absolute effect size between younger and older parents. As in the UK Biobank sample, correlations of PGS coefficients between younger and older parents are negative (`r cor_agefb`), and for `r n_discordant` out of `r length(pgs)` PGS, coefficients have opposite signs. However, in bootstraps, these statistics are not significantly different from 0 and `r length(pgs)/2` respectively. Also, in the UK Biobank sample, PGS coefficients on fertility controlling for age at first birth were negatively correlated with the uncontrolled coefficients; here, that isn't true, with coefficients remaining positively correlated.

```{r}
#| label: stat-control-agefb


# selection effects controlling for age at first birth
# 
form_pgs_control_agefb <- map(pgs, \(x) reformulate(c(x, "agefbn", pcs), 
                                                    response = "rlrs"))
mod_pgs_control_agefb <- map(form_pgs_control_agefb,
                             \(x) svyglm_quiet(x, rand, subset = 
                                                 ethnicity == "white"))
tidy_pgs_control_agefb <- map(mod_pgs_control_agefb, broom::tidy) |> 
                          list_rbind() |> 
                          filter(term %in% pgs)

cor_raw_controlled <- cor(tidy_pgs$white$estimate,
                          tidy_pgs_control_agefb$estimate)

stopifnot(cor_raw_controlled >= 0)


```

@tbl-x-bootstraps shows means and 95% confidence intervals for mean absolute coefficient sizes in each pair of groups, and the difference between them, using bootstraps. Differences for income and marriage are significant.

|               | Low group             | High group            | Difference            |
|------------------|------------------|------------------|------------------|
| Education     | `r tbl$edu[1]`        | `r tbl$edu[2]`        | `r tbl$edu[3]`        |
| Income        | `r tbl$income_med[1]` | `r tbl$income_med[2]` | `r tbl$income_med[3]` |
| Marriage      | `r tbl$married[1]`    | `r tbl$married[2]`    | `r tbl$married[3]`    |
| Age 1st birth | `r tbl$agefb[1]`      | `r tbl$agefb[2]`      | `r tbl$agefb[3]`      |
| Birth year    | `r tbl$born[1]`       | `r tbl$born[2]`       | `r tbl$born[3]`       |

: Bootstrap estimates and 95% confidence intervals for mean absolute coefficients of PGS on RLRS in "low" and "high" groups among white respondents. Groups are: 0-12 years education vs. 13-17 years; below vs. above median income; all others vs. married; below vs. above median age at first birth; born before vs. after 1942. `r n_reps_x_es` bootstraps. {#tbl-x-bootstraps tbl-colwidths="\[19,28,28,33\]"}

The economic theory of fertility also implies that correlations between education and RLRS should be more negative for lower-income/education people, single parents and people who have children earlier.[^1] This in turn implies that correlations between PGS coefficients on education and on RLRS should be more negative among these groups. we tested this with bootstraps, but confidence intervals were always too wide to be informative.

[^1]: See @hugh2022human equation (6) and following.

```{r}
#| label: stat-pgs-over-time
#| eval: false

# Plot changes in a couple of variables by decade
# Below: "Changes in PGS over time are small for both groups..."
 
rand$variables$birth_decade <- chop_width(rand$variables$rabyear, 10, 1920)
decades_adhd <- svyby(~ADHD_PGC17, ~ birth_decade + ethnicity, rand, 
                      FUN = svymean) 
decades_ea3 <- svyby(~EA3, ~ birth_decade + ethnicity, rand, 
                     FUN = svymean) 

# example plot
ggplot(decades_ea3, aes(birth_decade, EA3, color = ethnicity, 
                        group = ethnicity)) + 
  geom_line() +
  geom_pointrange(aes(ymax = EA3 + 1.96 * se, ymin = EA3 - 1.96 * se))


```

```{r}
#| label: stat-x-bootstrap-birthyear
#| cache: true

n_reps_birthyear <-  199

forms <- pgs |> map(\(x) reformulate(c(x, pcs), response = "raevbrn"))

calc_birthyear <- function (w, data) {
  data$w <- w
  mods_young <- map(forms, \(x) lm(x, data, subset = rabyear > 1945,
                                 weights = w))
  mods_old <- map(forms, \(x) lm(x, data, subset = rabyear <= 1945,
                                  weights = w))
  coefs_young <- map2_dbl(mods_young, pgs, \(x, y) coef(x)[[y]])
  coefs_old <- map2_dbl(mods_old, pgs, \(x, y) coef(x)[[y]])
  
  c(cor = cor(coefs_young, coefs_old))
}

rand_boot <- rand |> 
  subset(ethnicity == "white") |> 
  as.svrepdesign(type = "bootstrap", replicates = n_reps_birthyear)

cor_agefb <- withReplicates(rand_boot, theta = calc_birthyear)

```

Why does the US data show fewer differences by socio-economic status (SES) than the UK? One possibility is that SES maps on to race in the US, so that ethnic differences here capture some of the variation seen in the UK. The regression coefficient of phenotypic educational attainment on RLRS is more negative among black than white respondents (blacks: `r tidy_fert_edu_phen$black$estimate`, 95% C.I. `r tidy_fert_edu_phen$black$conf.low` to `r tidy_fert_edu_phen$black$conf.high`; whites: `r tidy_fert_edu_phen$white$estimate`, 95% C.I. `r tidy_fert_edu_phen$white$conf.low` to `r tidy_fert_edu_phen$white$conf.high`; cf. @goldscheider1969minority, @johnson1979minority, @yang2003big). And the slope of PGS education coefficients on fertility coefficients is larger among black respondents, though imprecisely estimated (see @fig-rlrs-edu). But comparisons of PGS selection coefficients between the ethnic groups are hard because of the smaller sample size and differences in the scores' predictive power, so this hypothesis can only be speculative. Looking within the sample, changes in PGS by birth year are small for both groups, and are probably mostly driven by selective mortality. Another possibility is that the US cohort were exposed to a smaller welfare state than the UK cohort, since many of them had children before the "Great Society" programs of the 1960s. The last line of @tbl-x-bootstraps shows that effect sizes are larger for respondents born after 1942, but the difference is imprecisely estimated and not significant.

Lastly, we would like to know natural selection's effect sizes. The bivariate correlations of PGS with RLRS gives the change in one generation in the PGS due to natural selection, measured in standard deviations. Polygenic scores contain error, so estimated correlations are biased towards zero compared to the correlation of the true PGS. They can be scaled up by

$$
\hat{\beta}_{TRUE} = \hat{\beta}_{PGS}\sqrt{\frac{h^2}{R^2_{PGS}}
}$$

where \$h\^2\$ is the heritability of the PGS target phenotype and \$R\^2\_{PGS}\$ is the \$R\^2\$ of the measured PGS on the target phenotype [@becker2021resource]. Moving from error correction in a univariate model to a multivariate model requires a slightly more complex correction, although it uses the same parameters. To do this we use the error-corrected estimator developed by \@becker2021resource.

SNP- or chip-heritabilities and $R^2_{PGS}$ are calculated by @becker2021resource for scores in the Polygenic Index Repository. The authors use GCTA to estimate heritability. When the corresponding phenotype is not available in the HRS to estimate $R^2_{PGS}$, we use parameters estimated by the authors in the Wisconsin Longitudinal Study instead. We also perform error correction with twin heritabilites. To attain precise estimates we use heritabilities from a meta-analysis including over 14,000 twin pairs authored by @polderman2015twin[^2]. We remove polygenic scores with $R^2_{PGS} > 0.005$ to focus on PGS with adequate power. This removed the ADHD PGS which significantly predicted RLRS, even after bonferroni correction.

[^2]: For age of first birth, we could not find an appropriately close trait in @polderman2015twin. For this trait we used a twin heritability of 0.15 as estimated in the Midlife in the United States (MIDUS) sample [@briley2017fertility].

@fig-true-effects reports the error corrected estimates of selection. As a rule of thumb, a 0.1 standard deviation change in a polygenic score over a generation might count as "serious": about 54% of the new generation will be below the parents' mean. Many upper confidence bounds meet that threshold, but lower bounds are often small or include zero. Age of First Birth has a twin corrected heritability of 0.15, implying that it maybe under fast selection. The confidence bounds capture uncertainty from sampling variation, but not other sources, including uncertainty about the true \$h\^2\$ , the true \$R\^2\_{PGS}\$, limitations of the within-sample phenotypes, noise from correlated environments, and for twin-heritability, different relationships with fertility among variants not measured on the chip. Given all this, the estimates mostly show the limits of our knowledge, and should be treated as best guesses only.

Results from a few traits show substantial uncertainty regarding the true effect size. For asthma, when chip heritability is used, the effect is positive and significant, but negative and significant when twin heritability is used! Such a large disparity is because @becker2021resource estimate the chip heritability at 0.015 and we use a twin heritability 0f 0.55. For personality traits, chip heritability is often low (e.g. $<0.05$) but twin heritabilities are often much higher ($≈0.4$) implying substantial missing heritability. For these traits, the confidence intervals on twin heritabilities are enormous. Error-corrected effect sizes and the $R^2$ and $h^2$ parameters used can be found on the Github page for this paper.

<!--# TE The lay public want to know how much IQ is changing. So I've added in a calculation of this. -->

To estimate how natural selection will contribute to changing the phenotype, we can multiply the change in the mean genetic value by the correlation between genetic values and phenotypes $h$, which is the square root of heritability. For cognitive performance we have estimated a genetic change of $-0.066$ standard deviations per generation, assuming a twin heritability of $0.51$. This implies a phenotypic change of $-0.066\times0.51^\frac{1}{2}=-0.047$ standard deviations per generation, equivalent to $-0.71$ points in the units of IQ, where a standard deviation is equal to $15$ points. This calculation assumes the heritability of the trait remains constant, that the genetic correlation across time is equal to one and it ignores the environmental contributions to changes in the phenotype. Given the assumptions required for this calculation, on top of the problems involved in estimating the genetic change, it can only be considered a guess.

<!--# TE It's hard to keep in the sanity check since we are jumping from LDSC back to GCTA to calcualte snp heritability with pgenscores. The above also uses PGI repository scores only. I can add the sanity check back in. To be fair, I'm only aware of the method being tested with different discovery sample sizes using simulated data (link below) the sanity check is useul. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10368647/-->

```{r}
#| label: stat-pgicorrect
#| cache: true

# Writing data for pgi_correct to use
readr::write_tsv(
  rand$variables |> filter(ethnicity == "white"),
  "pgi_correct_data.txt",
  quote = "none"
)

####################################
# Formatting parameter values to use
####################################

# correct_scores holds h2 and R2 values, as well as useful information about the PGS
# such as group categories taken from the PGI repository and simplified names
correct_scores <- readxl::read_excel("PGI_Heritabilities.xlsx", 
                                     na = "NA", range = "B1:U53")

# Where h2 and R2 are missing, we take values from a similar sample - the WLS
correct_scores$chip_h2 <- ifelse(is.na(correct_scores$HRS_h2), 
                                 correct_scores$WLS_h2,
                                 correct_scores$HRS_h2)

correct_scores$R2 <- ifelse(is.na(correct_scores$HRS_R2),
                            correct_scores$WLS_R2,
                            correct_scores$HRS_R2)

correct_scores$twin_h2 <- correct_scores$TwinH2
correct_scores$pgs     <- correct_scores$Abr

correct_scores$pgs <- case_match(correct_scores$pgs,
  "CANNABIS" ~ "CANNABISpgirep",
  "DPW"      ~ "DPWpgirep",
  "HEIGHT"   ~ "HEIGHTpgirep",
  .default = correct_scores$pgs
)

# some of the PGS have estimates rounded to zero and are thus useless
correct_scores <- filter(correct_scores, chip_h2 > 0, R2 > 0)

# TE I originally used 0.28 from the TED sample. But that leads to especially absurd estimates
# 0.15 was estiamted in the American MIDUS sample from the same paper.
# Leading to slightly less absurd estimates. Perhaps more appropriate in the American context.
# Uncertainty regarding parameters means results should be interepreted with CAUTION!!!
# adjustment to use Midus values for NEB is also used

correct_scores$twin_h2[correct_scores$pgs == "AFB"] <- 0.15
correct_scores$twin_h2[correct_scores$pgs == "NEBwomen"] <- 0.28


####################################
# Calculating error corrected estimates
####################################

run_pgic_once <- function (pgs, r2, h2, h2_type) {
  pgic_command <- glue(
     'python3 pgi_correct/pgic.py --reg-data-file pgi_correct_data.txt', 
     '--outcome "rlrs" --pgi-var {pgs}',
     '--covariates "PC1_5A" "PC1_5B" "PC1_5C" "PC1_5D" "PC1_5E" "PC6_10A"',
     '"PC6_10B" "PC6_10C" "PC6_10D" "PC6_10E" --R2 {r2} --h2 {h2}',
     '--weights "weight"', 
     .sep = " ")
  system(pgic_command)
      
  # This removes "junk" rows in the way of our regression betas
  system("sed '1d;2d;3d;4d;5d;6d;7d;8d;9d' pgi_correct.res > reg_results")
  pgic_results <- readr::read_table("reg_results", col_names = TRUE,
                                    col_types = "cdddd")
  file.remove("reg_results")
  
  tibble(
    trait = pgs,
    beta  = pgic_results[[1, 4]],
    SE    = pgic_results[[1, 5]],
    Heritability = h2_type
  )
}

run_pgic_data <- function (score_data, h2_column, h2_type) {
  results <- map(1:nrow(score_data), 
    \(i) run_pgic_once(pgs = score_data$pgs[i], 
                       r2 = score_data$R2[i],
                       h2 = score_data[i, h2_column, drop = TRUE],
                       h2_type = h2_type)
  )
  
  list_rbind(results)
}


corrected_effects_snp <- run_pgic_data(correct_scores, h2_column = "chip_h2",
                                       h2_type = "Chip")
corrected_effects_twin <- run_pgic_data(correct_scores, h2_column = "twin_h2",
                                        h2_type = "Twin")

corrected_effects <- rbind(corrected_effects_snp, corrected_effects_twin)
corrected_effects$conf.low <- corrected_effects$beta - 1.96 *
                              corrected_effects$SE
corrected_effects$conf.high <- corrected_effects$beta + 1.96 *
                               corrected_effects$SE

file.remove("pgi_correct_data.txt")

corrected_effects <- left_join(corrected_effects, correct_scores,
                               by = join_by(trait == Abr),
                               suffix = c("", ".y"))
  
# The odd looking results are for traits with large missing heritability e.g. Asthma. My guess is that the rare variants act somewhat differently as DHJ as argued, meaning traits with large missing heritability show nonsense twin heritability estimates.

corrected_effects$Category <-
  case_match(
    corrected_effects$Category,
    "Health and health behaviours"     ~ "Health",
    "Personality and well-being"       ~ "Personality",
    "Fertility and sexual development" ~ "Health",
    "Anthropometric"                   ~ "Health",
    "Cognition and education"          ~ "Cognition"
  )

# Cleaning and saving corrected effects so people can have the exact figures
corrected_effects$TwinH2_Source <- corrected_effects$Source
corrected_effects |> 
  select(trait, beta, SE, Heritability, chip_h2, twin_h2, R2, 
           TwinH2_Source, PoldermanICF_ICD10_subchapter, Category) |> 
  readr::write_csv("Corrected_effects.csv")

```

```{r}
#| label: fig-true-effects
#| warning: false
#| fig-cap: |
#|   Estimated coefficients of true polygenic scores on RLRS calculated
#|   using estimates of chip- and twin-heritability and the most recent
#|   polygenic score.
#| fig-height: 6.79
#| fig-width:  5.98


# TE Note that under Fisher's fundamental theorem of natural selection, the selection
# for fitness should be equal to it's heritability... But in HRS the
# the AFB PGS much more strongly predicts RLRS than the NEB PGS and it's selection
# is much lower than what the heritability of NEB should be.
# The low R2 of NEB causes it to be removed, but the genetics for NEB 
# could just be a little different in HRS versus other samples!
# NEB_result <-  corrected_effects-which(corrected_effects[,"trait"]=="NEBwomen"),]

  
corrected_effects |>
  # This removes ADHD due to the low power of the score. 
  # Note ADHD predict RLRS after bonferroni! 
  # It also removes NEB
  filter(R2 > 0.005) |> 
  mutate(
    trait = nice_names[trait],
    trait = fct_reorder(trait, beta)
  ) |>
  ggplot(aes(y = trait, x = beta, xmin = conf.low, xmax = conf.high,
           color = Heritability)) +
  geom_vline(xintercept = 0, color = "grey60") +
  geom_pointrange(aes(linetype = Heritability == "Twin"),
                  position = position_dodge(0.2)) +
  scale_linetype(guide = "none") +
  coord_cartesian(xlim = c(-0.3, 0.3)) +
  labs(x = "Corrected coefficient on RLRS", y = "") +
  theme_minimal() +
  facet_grid(Category ~ ., scales = "free_y", space = "free_y") +
  theme(strip.text.y = element_text(angle = -90,face = "bold"))
  
```

```{r}
#| label: stat-bootstrap-true-effects
#| cache: true
#| eval: false

#' Calculate corrected PGS
#'
#' @param w Weights
#' @param data Data frame
#' @param pgs Name(s) of polygenic score(s) columns in  `data`.
#' @param phenotype Name of target phenotype in `data`
#' @param chip_h2 Chip-heritability
#' @param twin_h2 Twin-study heritability
#'
#' @return A vector of corrected estimates of effects on fertility, 
#'   named like `source.to.target` 
#'   where `source` is one of `pgs` and target is either a `pgs` or the
#'   chip-PGS or true PGS. If `pgs` has more than one element then
#'   the function will correct pgs using each other as a sanity check. If
#'   `source == target` then that is the original uncorrected score.
#' @noRd
#'
#' @examples
boot_correct <- function (w, data, pgs, phenotype, chip_h2, twin_h2) {
  
  fs_fert <- map(pgs, \(x) reformulate(c(x, pcs), response = "rlrs"))
  fs_phen <- map(pgs, \(x) reformulate(c(x, pcs), response = phenotype))

  ms_fert <- map(fs_fert, \(x) lm(x, data = data, weights = w))
  ms_phen <- map(fs_phen, \(x) lm(x, data = data, weights = w))
  bhat_fert <- map2_dbl(ms_fert, pgs, \(x, y) coef(x)[[y]])
  bhat_phen <- map2_dbl(ms_phen, pgs, \(x, y) coef(x)[[y]])

  r2_phen <- map_dbl(ms_phen, \(x) {
    an <- car::Anova(x)
    an$`Sum Sq`[1]/sum(an$`Sum Sq`)  # incremental R2 of first term
  })

  r2_phen <- c(r2_phen, chip_h2, twin_h2)
  # the correction factor
  # lower triangular part of this shows how much you multiply to get from
  # COLNAME to ROWNAME
  rhos <- outer(r2_phen, r2_phen, \(x, y) sqrt(x/y)) 
  rownames(rhos) <- colnames(rhos) <- c(pgs, "Chip", "Twin")

  # multiply first column by bhat_edu[1] to give predictions from the
  # first PGS to the next ones; etc.
  # The diagonals of b_edu are exactly equal to bhat_edu
  # arow,column gives the predicted value of b by ROWNAME for COLNAME
  b_phen <- apply(rhos, 1, \(x) x * c(bhat_phen, NA, NA))
  b_fert <- apply(rhos, 1, \(x) x * c(bhat_fert, NA, NA))

  # don't include the last two rows of NA predictions "from chip/twin h2"
  b_fert <- b_fert[seq_along(pgs), , drop = FALSE]

  res <- c(b_fert)
  # TODO: are the "backward estimates" wrong?
  # TODO: check against the python tool from the PGI repository paper
  res_names <- outer(rownames(b_fert), colnames(b_fert),
                      \(x, y) paste0(x, ".to.", y))
  names(res) <- c(res_names)
  
  res
}

n_reps_true <- 199
rand_boot <- rand |> as.svrepdesign(type = "bootstrap", 
                                    replicates = n_reps_true)

correct_scores <- tibble::tribble(
  ~pgs                         , ~phenotype  , ~chip_h2, ~twin_h2,
  c("ADHD_PGC10", "ADHD_PGC17"), "adhd_score", 0.21    , 0.75    ,
  c("EDU2", "EDU3", "EA3")     , "raedyrs"   , 0.10    , 0.43    ,  
  "AFBC"                       , "agefbn"    , 0.05    , 0.26    ,
  "NEUROT"                     , "neurot"    , 0.10    , 0.37    ,
  "CD"                         , "r10hearte" , 0.22    , 0.4     ,
  "T2D"                        , "r10diabe"  , 0.18    , 0.22    , 
  c("MDD", "MDD2")             , "r10cesd"   , 0.08    , 0.37    ,
#  "ANXCC"                      , "anxiety"   , 0.31    , 0.45    ,
  "AI"                         , "age_smoked", 0.05    , 0.50    ,
  c("GENCOG", "GCOG2")         , "r10cogtot" , 0.19    , 0.86
)

correct_scores <- drop_na(correct_scores)
# Sources for chip/twin h2; Abdel.
# general cognition used h2 for "adult IQ"
# Except:
# heart disease 0.4 to 0.6 from https://www.nejm.org/doi/full/10.1056/nejm199404143301503
# via https://www.jacc.org/doi/full/10.1016/j.jacc.2014.12.033
# T2D  0.22 to 0.73...
# https://www.cell.com/ajhg/pdf/S0002-9297(12)00031-6.pdf
# https://www.cambridge.org/core/services/aop-cambridge-core/content/view/94E0005D626FB0399AA8FDDAC82F970E/S1832427415000833a.pdf/div-class-title-the-concordance-and-heritability-of-type-2-diabetes-in-34-166-twin-pairs-from-international-twin-registers-the-discordant-twin-discotwin-consortium-div.pdf
# anxiety (nb not social anxiety!)
# https://ajp.psychiatryonline.org/doi/full/10.1176/ajp.156.2.246
# generalized anxiet disorder 42%:
# https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0134865
# age of smoking initiation, including chip heritability
# http://www.matthewckeller.com/publications/Evans_Addiction_2021.pdf
# CAD chip heritability
# https://academic.oup.com/cardiovascres/article/113/8/973/2965332?login=false
# type ii diabetes chip heritability
# https://www.nature.com/articles/s41588-018-0241-6
# 'current anxiety symptoms' chip heritability
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7237282/

corrected_effects <- list()
for (i in seq(nrow(correct_scores))) {
  source_pgs <- correct_scores$pgs[[i]]
  phenotype <- correct_scores$phenotype[[i]]
  chip_h2 <- correct_scores$chip_h2[[i]]
  twin_h2 <- correct_scores$twin_h2[[i]]
  
  results <- withReplicates(rand_boot, theta = boot_correct, 
                            pgs = source_pgs, phenotype = phenotype, 
                            chip_h2 = chip_h2, twin_h2 = twin_h2)
  corrected_effects[[phenotype]] <- results |>
    as.data.frame() |>
    tibble::rownames_to_column(var = "rn") |>
    cbind(confint(results)) |>
    tibble::remove_rownames() |>
    setNames(c("rn", "mean", "SE", "conf.low", "conf.high")) |> 
    mutate(
      phenotype = phenotype,
      source.pgs = str_remove(rn, ".to.*"),
      target.pgs = str_remove(rn, ".*.to."),
      rn = NULL,
      .before = 1
    )
}

corrected_effects <- list_rbind(corrected_effects)
```

```{r}
#| label: fig-true-effects-old
#| eval: false
#| fig-cap: |
#|   Estimated coefficients of true polygenic scores on RLRS calculated
#|   using estimates of chip- and twin-heritability and the most recent
#|   polygenic score.

# TODO: maybe just use the polygenic score name not the phenotype?
# TODO: why are some result bounds negative? e.g. ADHD? Presumably
#. because can have negative effect on RLRS?
# TODO: check the original phenotypes from which h2 ests were derived...
#. - is CAD the same as coronary heart disease (r10hearte)?
# TODO: why is ANXCC not predicting anxiety?
corrected_effects |> 
  mutate(
    Phenotype = nice_names[source.pgs],
    Heritability = target.pgs
  ) |> 
  filter(Heritability %in% c("Chip", "Twin"), ! source.pgs %in% old_pgs) |> 
  ggplot(aes(y = Phenotype, x = mean, xmin = conf.low, xmax = conf.high,
             color = Heritability)) +
    geom_vline(xintercept = 0, color = "grey60") +
    geom_pointrange(aes(linetype = Heritability == "Twin"),
                    position = position_dodge(0.2)) +
    scale_linetype(guide = "none") +
    coord_cartesian(xlim = c(- 0.3, 0.3)) +
    labs(x = "Corrected coefficient on RLRS", y = "") +
    theme_minimal() 

```

# Discussion

The economic theory of fertility is driven by the trade-off between children and income. On the one hand, a higher hourly wage makes time raising children more costly (a "substitution effect"). On the other hand, higher expected income makes children more affordable (an "income effect"). Prediction 1 of the theory holds when substitution effects dominate income effects. Prediction 2 is driven by the specific form of individuals' preferences for income: when utility for income is sharply curved, the substitution effect is stronger for those who expect to earn less.

The results here support prediction 1 but are more ambiguous for prediction 2. PGS coefficients on RLRS also appear larger for low-income groups and unmarried respondents. But there is little evidence for larger coefficients among people with lower education, or younger parents. This may be due to the low sample size. But in the UK, the between-group differences were large [@hugh2022human]; differences that big would surely have been visible here. The theory can accommodate this non-result, if preferences for income are less curved in the US for whatever reason. But note that *any* theory with a negative relationship between education and fertility will give prediction 1.[^3] In this sense, results here are less supportive of the economic theory specifically.

[^3]: See @balbo2013fertility for a broad review of fertility theories.

The smaller black sample makes most tests inconclusive for this population: we can only say that the data do not reject a negative association between PGS correlations with RLRS and PGS correlations with education. Lastly, estimated effect sizes of "true" polygenic scores are typically between 0-0.2 standard deviations. To know more, we must await more accurate scores.

# Appendix

## Acknowledgements

The HRS (Health and Retirement Study) is sponsored by the National Institute on Aging (grant number NIA U01AG009740) and is conducted by the University of Michigan.

Code to reproduce this paper is available at <https://github.com/hughjonesd/hrs-selection>.

## Figures

```{r}
#| label: fig-cohorts
#| fig-cap: Distribution of birth years for the sample

rand$variables |> 
    mutate(
      Ethnicity = fct_relevel(titles[ethnicity], "White", "Black")
    ) |> 
    ggplot(aes(rabyear, fill = Ethnicity)) + 
      geom_bar(position = "identity") +
      labs(x = "Birth year", y = "Count") +
      scale_fill_manual(values = c(Black = "orange2", White = "steelblue4")) +
      theme_minimal() +
      theme(legend.title = element_blank())  

```

```{r}
#| label: fig-rlrs
#| fig-cap: |
#|  Coefficients of PGS on RLRS among white respondents, controlling for 10
#|  principal components of
#|  genomic array data. Lines are 95% confidence intervals.
#| fig-height: 6


tidy_pgs$white |>
  mutate(
    term = nice_names[term],
    term = fct_reorder(term, estimate)
  ) |>
  ggplot(aes(estimate, term)) +
    geom_vline(xintercept = 0) +
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high), size = 0.3,
                    color = "steelblue3") +
    theme_light() + 
    labs(
      x = "", y = "",
      title = "Coefficients of polygenic scores on RLRS"
    ) +
    theme(
      axis.text.y = element_text(size = 7),
      panel.grid.major.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      legend.position = "none"
    )


```

```{r}
#| label: fig-siblings
#| fig-cap: |
#|   Scatterplot of PGS coefficients on number of live siblings and years of
#|   education. Controls include 10 principal components of genetic array
#|   data. Dashed lines show linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <-  
    tidy_pgs_sibs[[eth]] |> 
    inner_join(tidy_pgs_ed[[eth]], 
               by = join_by(term), suffix = c(".sibs", ".edyrs")) |> 
    ggplot(aes(estimate.edyrs, estimate.sibs)) +
      geom_hline(yintercept = 0, color = "grey80") +
      geom_vline(xintercept = 0, color = "grey80") +
      geom_point() +
      geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                  linetype = "dashed", colour = "red", linewidth = 0.5) +
      coord_cartesian(xlim = c(-.3, .75)) +
      theme_light() + 
      theme(panel.grid = element_blank()) +
      labs(
          title = eth,
          x = "Coefficient on years of education",
          y = "Coefficient on number of siblings"
      )
  print(ggp)
}
```

```{r}
#| label: fig-gkids
#| fig-cap: |
#|   Scatterplot of PGS coefficients on RLRS2 and years of
#|   education. RRS2 is the reproductive success of respondent's offspring relative to the success of other offspring. Controls include 10 principal components of genetic array
#|   data. Dashed lines show linear regressions.
#| fig-subcap:
#|   - ""
#|   - ""
#| layout-nrow: 2
#| column: page


for (eth in eths) {
  ggp <-  
    tidy_pgs_gkids[[eth]] |> 
    inner_join(tidy_pgs_ed[[eth]], 
               by = join_by(term), suffix = c(".gkids", ".edyrs")) |> 
    ggplot(aes(estimate.edyrs, estimate.gkids)) +
      geom_hline(yintercept = 0, color = "grey80") +
      geom_vline(xintercept = 0, color = "grey80") +
      geom_point() +
      geom_smooth(method = "lm", formula = y ~ x, se = FALSE, 
                  linetype = "dashed", colour = "red", linewidth = 0.5) +
      coord_cartesian(xlim = c(-.3, .75)) +
      theme_light() + 
      theme(panel.grid = element_blank()) +
      labs(
          title = eth,
          x = "Coefficient on years of education",
          y = "Coefficient on RRS2"
      )
  print(ggp)
}

```

```{r}
#| label: prog-x-plots

geom_x_boxplot <- geom_boxplot(color = "grey50", outlier.shape = NA)
geom_x_point <- geom_point(aes(shape = pgs=="EA3"), 
                           position = position_jitter(width = 0.03), 
                           alpha = 0.5) 

themes_x <- theme_minimal() +
      theme(
          legend.position = "none",
          panel.grid.major.x = element_blank()
      ) 
```

```{r}
#| label: fig-x-edu
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within the low/high
#|   education group. Boxes show quartiles. 

tidy_pgs_x_ed$white |> 
  mutate(
    Education = str_remove(edu, "edu")
  ) |> 
  ggplot(aes(Education, abs(estimate), color = Education)) +
    geom_x_boxplot + geom_x_point +
    labs(
      x = "Years of education",
      y = "Absolute coefficient",
      title = paste("PGS coefficients on RLRS by education", 
                    calc_n(mod_pgs_x_ed))
    ) +
    themes_x
```

```{r}
#| label: fig-x-inc
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within the below/above
#|   median income group. Boxes show quartiles.

tidy_pgs_x_inc$white |> 
  mutate(
    Income = fct_relevel(income_med, c("Low", "High"))
  ) |> 
  ggplot(aes(Income, abs(estimate), color = Income)) +
    geom_x_boxplot + geom_x_point +
    labs(
      x = "Income",
      y = "Absolute coefficient",
      title = paste("PGS coefficients on RLRS by income", 
                    calc_n(mod_pgs_x_inc))
    ) +
    themes_x
```

```{r}
#| label: fig-x-mar
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within married 
#|   and other respondents. Boxes show quartiles.

tidy_pgs_x_mar$white |> 
    mutate(
      married = fct_relevel(married, "Other", "Married")
    ) |> 
    ggplot(aes(married, abs(estimate), color = married)) +
      geom_x_boxplot + geom_x_point +
      labs(
          x = "Married",
          y = "Absolute coefficient",
          title = paste("PGS coefficients on RLRS by marital status", 
                        calc_n(mod_pgs_x_mar))
      ) +
      themes_x

```

```{r}
#| label: fig-x-agefb
#| fig-cap: |
#|   Boxplots of polygenic score coefficients on RLRS 
#|   among white respondents, controlling for 10 principal 
#|   components of genetic array data, estimated within below/above
#|   median age at first birth respondents. Boxes show quartiles.

tidy_pgs_x_agefb$white |> 
    mutate(
      agefb = fct_relevel(agefb, "Low", "High")
    ) |> 
    ggplot(aes(agefb, abs(estimate), color = agefb)) +
      geom_x_boxplot + geom_x_point + 
      labs(
          x = "Age at first birth",
          y = "Absolute coefficient",
          title = paste("PGS coefficients on RLRS by age at first birth", 
                        calc_n(mod_pgs_x_agefb))
      ) +
      themes_x

```

```{r}
#| label: fig-check-correction
#| eval: false
#| fig-cap: |
#|   Estimated coefficients of series of PGS on fertility 
#|   using errors-in-variables correction. "Own" is the uncorrected estimate
#|   using the PGS itself. Other estimates are from earlier PGS targeting
#|   the same phenotype, corrected via the method in @becker2021resource.
#| fig-height: 6

corrected_effects |> 
  filter(length(unique(source.pgs)) > 1, .by = phenotype) |> 
  filter(! target.pgs %in% c("Chip", "Twin")) |> 
  filter(
    ! target.pgs %in% old_pgs
  ) |> 
  mutate(
    Phenotype = case_match(phenotype,
                           "adhd_score" ~ "ADHD",
                           "r10cesd" ~ "Depression",
                           "r10cogtot" ~ "Cognition",
                           "raedyrs" ~ "Educ. attainment"
                           ),
    Target = target.pgs,
    Source = ifelse(source.pgs == target.pgs, "Own", source.pgs),
  ) |> 
  ggplot(aes(y = Target, x = mean, xmin = conf.low, xmax = conf.high,
             color = Source)) +
    geom_vline(xintercept = 0, color = "grey60") +
    geom_pointrange(position = position_dodge(0.7)) +
    geom_text(aes(x = mean, label = Source), hjust = "center", 
              vjust = 1.5,
              position = position_dodge(0.7), size = 2.5) + 
    scale_color_manual(values = c("Own" = "red"), guide = "none") +
    facet_grid(rows = vars(Phenotype), scales = "free", space = "free") +
    labs(x = "Corrected coefficient on RLRS", y = "Target PGS") +
    coord_cartesian(xlim = c(-0.05, 0.05)) + 
    theme_minimal() 

```

\FloatBarrier

# Bibliography
